/**
 * Utility functions for backend operations
 * Filename: backend/utils.jsw
 */
import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// Cached URL so we don't hit Secrets Manager on every single call
let CACHED_GAS_URL = null;
const FALLBACK_GAS_URL = 'https://script.google.com/macros/s/AKfycbxdKuWmcBo7Cu0RXsBgongINERqFoPE8CmfcdxtLdnJoM3SxuqBHGJY-pIrMbRi72_rnQ/exec';

/**
 * Get GAS Web App URL with Caching & Fallback
 */
export async function getGasUrl() {
    if (CACHED_GAS_URL) return CACHED_GAS_URL;
    try {
        const url = await getSecret("GAS_WEB_APP_URL");
        if (url) {
            const cleanUrl = url.trim();
            CACHED_GAS_URL = cleanUrl;
            return cleanUrl;
        }
    } catch (e) {
        console.warn("GAS_WEB_APP_URL secret not found, using fallback.");
    }
    return FALLBACK_GAS_URL;
}

// Cached API Key
let CACHED_GAS_API_KEY = null;

/**
 * Get GAS API Key from Secrets
 */
export async function getGasApiKey() {
    if (CACHED_GAS_API_KEY) return CACHED_GAS_API_KEY;
    try {
        const key = await getSecret("GAS_API_KEY");
        if (key) {
            const cleanKey = key.trim();
            CACHED_GAS_API_KEY = cleanKey;
            return cleanKey;
        }
    } catch (e) {
        console.warn("GAS_API_KEY secret not found.");
    }
    return null;
}

/**
 * Generate a cryptographically secure random token
 * Used for magic links and session tokens
 * @returns {string} A 64-character hex token
 */
export function generateToken() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let token = '';
    for (let i = 0; i < 64; i++) {
        token += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return token;
}

export async function fetchWithRetry(url, options = {}, retries = 3, backoff = 1000) {
    try {
        const response = await fetch(url, options);
        if (response.ok) return response;
        if (response.status >= 400 && response.status < 500 && response.status !== 429) {
            return response;
        }
        throw new Error(`Request failed with status: ${response.status}`);
    } catch (error) {
        if (retries > 0) {
            console.warn(`Fetch failed. Retrying in ${backoff}ms... (${retries} attempts left)`);
            await new Promise(resolve => setTimeout(resolve, backoff));
            return fetchWithRetry(url, options, retries - 1, backoff * 2);
        }
        throw error;
    }
}
