/**
 * Portal Authentication Module
 * backend/portal-auth.jsw
 * 
 * Complete authentication system for Shamrock Bail Bonds Portal
 * Handles magic links, session management, and role-based access
 * 
 * STAFF LOGIN POLICY:
 * - admin@shamrockbailbonds.biz ‚Üí Admin role (full access)
 * - shamrockbailoffice@gmail.com ‚Üí Staff role (standard access)
 * - All other users ‚Üí Default to indemnitor role (or defendant if found in Cases)
 * 
 * @version 2.0.0
 * @updated 2026-01-23
 */

import wixData from 'wix-data';
import { generateToken, hashPassword, verifyPassword } from 'backend/auth-utils';
import { getConfig } from 'backend/config-loader';
import { getGasWebAppUrl, getGasApiKey } from 'backend/secretsManager';
import { sendSms } from 'backend/twilio-client';
import { fetch } from 'wix-fetch';
import { fetchWithRetry } from 'backend/utils';
import crypto from 'crypto';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
    // Session settings
    SESSION_DURATION_HOURS: 24,
    MAGIC_LINK_EXPIRY_HOURS: 24,
    MAGIC_LINK_GRACE_PERIOD_MS: 5 * 60 * 1000,

    // Collections
    SESSIONS_COLLECTION: 'PortalSessions',
    MAGIC_LINKS_COLLECTION: 'Magiclinks',
    CASES_COLLECTION: 'Cases',

    // Portal URLs
    BASE_URL: 'https://www.shamrockbailbonds.biz',
    PORTAL_LANDING: '/portal-landing',

    // STAFF_ACCOUNTS removed as per instruction
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================



/**
 * Normalize email to lowercase
 */
function normalizeEmail(email) {
    return email ? email.toLowerCase().trim() : '';
}

/**
 * Normalize phone number to E.164 format
 */
function normalizePhone(phone) {
    if (!phone) return '';
    let digits = phone.replace(/\D/g, '');
    if (digits.length === 10) {
        return '+1' + digits;
    } else if (digits.length === 11 && digits.startsWith('1')) {
        return '+' + digits;
    }
    return phone;
}

/**
 * Check if input is email or phone
 */
function isEmail(input) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input);
}

// ============================================================================
// STAFF ACCOUNT HELPERS
// ============================================================================

/**
 * Check if email is a hardcoded staff account
 */
/**
 * Check if email is a hardcoded staff account
 */
function isStaffAccount(email, staffConfig) {
    if (!staffConfig) return false;
    const normalized = normalizeEmail(email);
    return staffConfig.hasOwnProperty(normalized);
}

/**
 * Get staff account details
 */
function getStaffAccountDetails(email, staffConfig) {
    if (!staffConfig) return null;
    const normalized = normalizeEmail(email);
    return staffConfig[normalized] || null;
}

// ============================================================================
// USER LOOKUP
// ============================================================================

/**
 * Look up user by email or phone in Cases collection
 * Returns role and person info if found
 */


/**
 * Helper: Build a robust phone query
 * Checks multiple formats: E.164, Raw 10-digit, Formatted
 */
function buildPhoneQuery(collection, field, phoneInput) {
    const clean = phoneInput.replace(/\D/g, ''); // 2395551234
    const e164 = clean.length === 10 ? '+1' + clean : '+' + clean;
    const formatted = clean.length === 10 ?
        `(${clean.substring(0, 3)}) ${clean.substring(3, 6)}-${clean.substring(6)}` : phoneInput;

    // Create an OR query for all variants
    return wixData.query(collection)
        .eq(field, e164)
        .or(wixData.query(collection).eq(field, clean))
        .or(wixData.query(collection).eq(field, formatted))
        .or(wixData.query(collection).contains(field, clean.substring(clean.length - 7))); // Last 7 digits backup
}

/**
 * Look up user by email or phone in Cases collection
 * Returns role and person info if found
 */
export async function lookupUserByContact(contact) {
    try {
        const config = await getConfig();
        const staffConfig = config.staffAccounts || {};

        const normalized = isEmail(contact)
            ? normalizeEmail(contact)
            : normalizePhone(contact);

        // 1. Check if it's a staff account
        if (isEmail(contact) && isStaffAccount(contact, staffConfig)) {
            const staffDetails = getStaffAccountDetails(contact, staffConfig);
            console.log(`‚úÖ Staff account identified: ${staffDetails.name} (${staffDetails.role})`);
            return {
                found: true,
                personId: staffDetails.personId,
                role: staffDetails.role,
                email: normalized,
                name: staffDetails.name,
                isStaff: true
            };
        }

        // 2. Search in Cases collection
        let results = { items: [] };

        if (isEmail(contact)) {
            // Check defendant email
            results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('defendantEmail', normalized)
                .find({ suppressAuth: true });
        } else {
            // Check defendant phone (Fuzzy Match)
            const query = buildPhoneQuery(CONFIG.CASES_COLLECTION, 'defendantPhone', contact);
            results = await query.find({ suppressAuth: true });
        }

        if (results.items.length > 0) {
            const caseData = results.items[0];
            return {
                found: true,
                personId: caseData._id,
                role: 'defendant',
                caseId: caseData._id,
                email: caseData.defendantEmail,
                phone: caseData.defendantPhone,
                name: caseData.defendantName
            };
        }

        // 3. Check indemnitor fields
        if (isEmail(contact)) {
            results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorEmail', normalized)
                .find({ suppressAuth: true });
        } else {
            // Check indemnitor phone (Fuzzy Match)
            const query = buildPhoneQuery(CONFIG.CASES_COLLECTION, 'indemnitorPhone', contact);
            results = await query.find({ suppressAuth: true });
        }

        if (results.items.length > 0) {
            const caseData = results.items[0];
            return {
                found: true,
                personId: 'indemnitor_' + caseData._id,
                role: 'indemnitor',
                caseId: caseData._id,
                email: caseData.indemnitorEmail,
                phone: caseData.indemnitorPhone,
                name: caseData.indemnitorName
            };
        }

        // 4. Not found - will be treated as new user
        return {
            found: false,
            contact: normalized
        };

    } catch (error) {
        console.error('Error in lookupUserByContact:', error);
        return { found: false, error: error.message };
    }
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

/**
 * Create a custom session for a user
 * @param {string} personId
 * @param {string} role
 * @param {string} caseId
 * @param {Object} contactInfo - { email, phone, name } (optional)
 */
/**
 * Create a custom session for a user
 * IMPROVED: Reuses existing active session if valid to prevent duplicates
 * @param {string} personId
 * @param {string} role
 * @param {string} caseId
 * @param {Object} contactInfo - { email, phone, name } (optional)
 */
export async function createCustomSession(personId, role, caseId = null, contactInfo = {}) {
    try {
        console.log(`üîê Creating session for ${role} (${personId})...`);

        // HARDENING: Enforce Allowlisted Roles
        const ALLOWED_ROLES = ['indemnitor', 'defendant', 'staff', 'admin', 'coindemnitor'];
        let targetRole = role;
        if (!ALLOWED_ROLES.includes(targetRole)) {
            console.warn(`SECURITY WARNING: Attempted to create session with invalid role '${role}'. Defaulting to 'indemnitor'.`);
            targetRole = 'indemnitor';
        }

        // 1. Check for existing active session to REUSE
        try {
            const existingSessions = await wixData.query(CONFIG.SESSIONS_COLLECTION)
                .eq('personId', personId)
                .eq('role', targetRole)
                .eq('isActive', true)
                .gt('expiresAt', new Date()) // Must be valid
                .descending('createdAt')
                .limit(1)
                .find({ suppressAuth: true });

            if (existingSessions.items.length > 0) {
                const activeSession = existingSessions.items[0];
                // Check if it has enough time remaining (e.g., > 4 hours)
                const remainingTime = new Date(activeSession.expiresAt).getTime() - new Date().getTime();
                if (remainingTime > 4 * 60 * 60 * 1000) {
                    console.log(`‚ôªÔ∏è Reusing existing valid session: ${activeSession._id}`);
                    return activeSession.sessionToken;
                }
            }
        } catch (checkErr) {
            console.warn("‚ö†Ô∏è Error checking existing sessions:", checkErr);
            // Continue to create new one if check fails
        }

        // 2. Create New Session
        const sessionToken = generateToken(48);
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + CONFIG.SESSION_DURATION_HOURS);

        const sessionData = {
            sessionToken: sessionToken,
            personId: personId,
            role: targetRole,
            caseId: caseId,
            email: contactInfo.email || null,
            phone: contactInfo.phone || null,
            name: contactInfo.name || null,
            createdAt: new Date(),
            expiresAt: expiresAt,
            isActive: true
        };

        await wixData.insert(CONFIG.SESSIONS_COLLECTION, sessionData, { suppressAuth: true });

        console.log(`‚úÖ New Session created for ${personId} with role ${targetRole}`);
        return sessionToken;

    } catch (error) {
        console.error('Error creating session:', error);
        throw error;
    }
}

/**
 * Validate a custom session token
 */
/**
 * Validate a custom session token
 * Returns distinct error states for frontend handling
 */
export async function validateCustomSession(sessionToken) {
    try {
        if (!sessionToken) {
            return { valid: false, reason: 'no_token' };
        }

        // Query multiple potential field keys to be safe
        const results = await wixData.query(CONFIG.SESSIONS_COLLECTION)
            .eq('sessionToken', sessionToken)
            .eq('isActive', true)
            .find({ suppressAuth: true });

        if (results.items.length === 0) {
            console.warn(`‚ö†Ô∏è Session validation failed: Token not found or inactive. Token: ${sessionToken.substring(0, 10)}...`);
            return { valid: false, reason: 'invalid' };
        }

        const session = results.items[0];

        // Check expiration
        if (new Date(session.expiresAt) < new Date()) {
            console.warn(`‚ö†Ô∏è Session expired. Expiry: ${session.expiresAt}, Now: ${new Date()}`);
            // Mark as inactive
            session.isActive = false;
            await wixData.update(CONFIG.SESSIONS_COLLECTION, session, { suppressAuth: true });
            return { valid: false, reason: 'expired' };
        }

        return {
            valid: true,
            personId: session.personId,
            role: session.role,
            caseId: session.caseId,
            email: session.email,
            phone: session.phone,
            name: session.name,
            createdAt: session.createdAt,
            expiresAt: session.expiresAt,
            sessionToken: session.sessionToken // Return for robust checks
        };

    } catch (error) {
        console.error('‚ùå Error validating session:', error);
        // CRITICAL FIX: Return 'error' reason so frontend knows it's a system/network issue
        // and doesn't immediately log the user out.
        return { valid: false, reason: 'error', message: error.message };
    }
}

/**
 * Invalidate a session (logout)
 */
export async function invalidateSession(sessionToken) {
    try {
        const results = await wixData.query(CONFIG.SESSIONS_COLLECTION)
            .eq('sessionToken', sessionToken)
            .find({ suppressAuth: true });

        if (results.items.length > 0) {
            const session = results.items[0];
            session.isActive = false;
            session.invalidatedAt = new Date();
            await wixData.update(CONFIG.SESSIONS_COLLECTION, session, { suppressAuth: true });
        }

        return { success: true };

    } catch (error) {
        console.error('Error invalidating session:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// MAGIC LINK GENERATION & VALIDATION
// ============================================================================

/**
 * Generate a magic link token
 * @param {string} personId - Person identifier
 * @param {string} role - User role
 * @param {string} caseId - Case identifier (optional)
 * @param {Object} options - { email, phone, name } (optional)
 */
export async function generateMagicLink(personId, role, caseId = null, options = {}) {
    try {
        const token = generateToken(32);
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + CONFIG.MAGIC_LINK_EXPIRY_HOURS);

        const linkData = {
            token: token,
            personId: personId,
            role: role,
            caseId: caseId,
            email: options.email || null,
            phone: options.phone || null,
            name: options.name || null,
            createdAt: new Date(),
            expiresAt: expiresAt,
            used: false
        };

        await wixData.insert(CONFIG.MAGIC_LINKS_COLLECTION, linkData, { suppressAuth: true });

        console.log(`‚úÖ Magic link generated for ${personId} (${options.email || 'no-email'})`);
        return token;

    } catch (error) {
        console.error('Error generating magic link:', error);
        throw error;
    }
}

/**
 * Validate magic link token and create session
 */
export async function onMagicLinkLoginV2(token) {
    try {
        if (!token) {
            return { ok: false, message: 'No token provided' };
        }

        // Find the magic link (allow used ones for grace period check)
        const results = await wixData.query(CONFIG.MAGIC_LINKS_COLLECTION)
            .eq('token', token)
            .find({ suppressAuth: true });

        if (results.items.length === 0) {
            return { ok: false, message: 'Invalid or expired link' };
        }

        const linkData = results.items[0];
        const now = new Date();

        // Anti-Scanner Logic: Allow reused token within grace period (idempotency)
        if (linkData.used) {
            const usedAt = new Date(linkData.usedAt);
            const timeDiff = now - usedAt;
            if (!linkData.usedAt || Number.isNaN(usedAt.getTime())) {
                console.warn('‚ö†Ô∏è Token marked used without valid usedAt; treating as used.');
                return { ok: false, message: 'Link already used' };
            }
            if (timeDiff < CONFIG.MAGIC_LINK_GRACE_PERIOD_MS) {
                console.log('‚ö†Ô∏è Token reused within grace period (Scanner defense)');
                // Create session anyway
                const sessionToken = await createCustomSession(
                    linkData.personId,
                    linkData.role,
                    linkData.caseId,
                    {
                        email: linkData.email,
                        phone: linkData.phone,
                        name: linkData.name
                    }
                );
                return {
                    ok: true,
                    sessionToken: sessionToken,
                    wixSessionToken: null,
                    role: linkData.role,
                    personId: linkData.personId
                };
            }
            return { ok: false, message: 'Link already used' };
        }

        // ... Normal flow ...

        // Check expiration
        if (new Date(linkData.expiresAt) < now) {
            return { ok: false, message: 'Link has expired' };
        }

        // Mark as used
        linkData.used = true;
        linkData.usedAt = now;
        await wixData.update(CONFIG.MAGIC_LINKS_COLLECTION, linkData, { suppressAuth: true });

        // Create session
        const sessionToken = await createCustomSession(
            linkData.personId,
            linkData.role,
            linkData.caseId,
            {
                email: linkData.email,
                phone: linkData.phone,
                name: linkData.name
            }
        );

        return {
            ok: true,
            sessionToken: sessionToken,
            wixSessionToken: null,
            role: linkData.role,
            personId: linkData.personId
        };

    } catch (error) {
        console.error('Error validating magic link:', error);
        return { ok: false, message: error.message };
    }
}

// ============================================================================
// SIMPLIFIED MAGIC LINK FLOW (Main Entry Point)
// ============================================================================

/**
 * Simplified magic link flow - single entry point for portal-landing
 * Handles both email and phone, new and existing users
 */
export async function sendMagicLinkSimplified(emailOrPhone) {
    try {
        const input = emailOrPhone.trim();
        const isEmailInput = isEmail(input);

        // 1. Look up user
        const lookup = await lookupUserByContact(input);

        let personId, role, caseId, email, phone, name;
        let isNewUser = false;

        if (lookup.found) {
            // Existing user
            personId = lookup.personId;
            role = lookup.role;
            caseId = lookup.caseId;
            email = lookup.email;
            phone = lookup.phone;
            name = lookup.name;
        } else {
            // New user - default to indemnitor role
            isNewUser = true;
            personId = 'new_' + generateToken(16);
            role = 'indemnitor';
            email = isEmailInput ? normalizeEmail(input) : null;
            phone = !isEmailInput ? normalizePhone(input) : null;
            name = null;
        }

        // 2. Generate magic link
        const token = await generateMagicLink(personId, role, caseId, {
            email: email,
            phone: phone,
            name: name
        });
        const magicLinkUrl = `${CONFIG.BASE_URL}${CONFIG.PORTAL_LANDING}?token=${encodeURIComponent(token)}`;

        // 3. Send via appropriate channel
        if (isEmailInput && email) {
            // Send via email
            const emailResult = await sendMagicLinkEmail(email, magicLinkUrl, role, name);
            if (!emailResult.success) {
                return { success: false, message: 'Failed to send email: ' + emailResult.error };
            }
        } else if (!isEmailInput && phone) {
            // Send via SMS
            const smsBody = `Shamrock Bail Bonds: Access your secure portal here: ${magicLinkUrl}. This link expires in 24 hours. Reply STOP to opt out.`;
            const smsResult = await sendSms(phone, smsBody);
            if (!smsResult.success) {
                return { success: false, message: 'Failed to send SMS: ' + smsResult.error };
            }
        } else {
            return { success: false, message: 'Unable to determine contact method' };
        }

        return {
            success: true,
            isNewUser: isNewUser,
            role: role,
            message: isEmailInput
                ? 'Check your email for your secure login link'
                : 'Check your phone for your secure login link'
        };

    } catch (error) {
        console.error('Error in sendMagicLinkSimplified:', error);
        return { success: false, message: error.message };
    }
}

/**
 * Send magic link via email
 */
async function sendMagicLinkEmail(email, magicLinkUrl, role, name) {
    try {
        // Use GAS backend to send email
        const gasUrl = await getGasWebAppUrl();
        const apiKey = await getGasApiKey();

        console.log('üîß sendMagicLinkEmail DEBUG:');
        console.log('  - GAS URL:', gasUrl ? 'SET' : 'MISSING');
        console.log('  - API Key:', apiKey ? 'SET' : 'MISSING');
        console.log('  - Recipient:', email.replace(/(.{2})(.*)(@.*)/, '$1***$3'));
        console.log('  - Role:', role);

        const roleLabels = {
            'admin': 'Administrator',
            'staff': 'Staff',
            'defendant': 'Client',
            'indemnitor': 'Cosigner'
        };

        const emailBody = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <div style="background: #1a5f2a; padding: 20px; text-align: center;">
                    <h1 style="color: white; margin: 0;">Shamrock Bail Bonds</h1>
                </div>
                <div style="padding: 30px; background: #f9f9f9;">
                    <p>Hello${name ? ' ' + name : ''},</p>
                    <p>Click the button below to securely access your ${roleLabels[role] || 'Client'} Portal:</p>
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="${magicLinkUrl}" style="background: #1a5f2a; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold;">
                            Access Your Portal
                        </a>
                    </div>
                    <p style="color: #666; font-size: 14px;">This link will expire in 24 hours.</p>
                    <p style="color: #666; font-size: 14px;">If you didn't request this link, please ignore this email.</p>
                </div>
                <div style="background: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
                    <p style="margin: 0;">Shamrock Bail Bonds, LLC</p>
                    <p style="margin: 5px 0;">1528 Broadway, Fort Myers, FL 33901</p>
                    <p style="margin: 0;">(239) 332-2245</p>
                </div>
            </div>
        `;

        const payload = {
            action: 'sendEmail',
            apiKey: apiKey,
            to: email,
            subject: 'Your Secure Portal Access - Shamrock Bail Bonds',
            htmlBody: emailBody
        };

        console.log('üì§ Sending email request to GAS...');

        const response = await fetchWithRetry(gasUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        console.log('üì• GAS Response Status:', response.status);

        const responseText = await response.text();
        console.log('üì• GAS Response Body:', responseText);

        if (!response.ok) {
            const maskedUrl = gasUrl.length > 20 ? '...' + gasUrl.slice(-20) : gasUrl;
            throw new Error(`GAS Network Error (${response.status} ${response.statusText}) at [${maskedUrl}]`);
        }


        // const data = await response.json(); // REMOVED: Body already read as text
        // if (!data || !data.success) { ... } // Logic moved below after parsing text

        // Try to parse response as JSON
        let responseData;
        try {
            responseData = JSON.parse(responseText);
            console.log('‚úÖ Parsed GAS response:', responseData);
        } catch (e) {
            console.warn('‚ö†Ô∏è Could not parse GAS response as JSON');
            responseData = { success: true }; // Assume success if we got 200 OK
        }

        if (responseData.success === false) {
            const errorMsg = typeof responseData.error === 'object' ?
                JSON.stringify(responseData.error) :
                (responseData.error || 'Unknown error');

            console.error('‚ùå GAS returned success: false:', errorMsg);
            throw new Error('GAS error: ' + errorMsg);
        }

        console.log('‚úÖ Email sent successfully!');
        return { success: true };

    } catch (error) {
        console.error('‚ùå CRITICAL ERROR in sendMagicLinkEmail:', error);
        console.error('   Error message:', error.message);
        console.error('   Error stack:', error.stack);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// STAFF DASHBOARD DATA
// ============================================================================

/**
 * Get staff dashboard data (stats and cases)
 */
export async function getStaffDashboardData() {
    try {
        // Get all cases
        const casesResult = await wixData.query(CONFIG.CASES_COLLECTION)
            .descending('_createdDate')
            .descending('_createdDate')
            .limit(1000)
            .find({ suppressAuth: true });

        const cases = casesResult.items;

        // Calculate stats
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const stats = {
            activeCases: cases.filter(c => c.status === 'active' || c.status === 'pending').length,
            pendingSignatures: cases.filter(c => c.paperworkStatus === 'pending').length,
            completedToday: cases.filter(c => {
                const created = new Date(c._createdDate);
                return created >= today && c.status === 'completed';
            }).length,
            failedChecks: cases.filter(c => c.status === 'failed').length
        };

        // Format cases for display
        const formattedCases = cases.map(c => ({
            _id: c._id,
            caseNumber: c.caseNumber || 'N/A',
            defendantName: c.defendantName || 'Unknown',
            bondAmount: c.bondAmount ? '$' + Number(c.bondAmount).toLocaleString() : 'N/A',
            status: c.status || 'pending',
            paperworkStatus: c.paperworkStatus || 'not_started',
            county: c.county || 'N/A',
            createdAt: c._createdDate
        }));

        // Fetch System Status from GAS
        let systemLogs = [];
        try {
            const gasUrl = await getGasWebAppUrl();
            const apiKey = await getGasApiKey();
            // 3-second timeout for status check
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);

            const statusResp = await fetch(gasUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'getSystemStatus', apiKey: apiKey }),
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (statusResp.ok) {
                const statusJson = await statusResp.json();
                if (statusJson.logs) systemLogs = statusJson.logs;
            }
        } catch (e) {
            console.warn("Failed to fetch GAS status:", e);
        }

        return {
            stats: stats,
            cases: formattedCases,
            systemLogs: systemLogs
        };

    } catch (error) {
        console.error('Error getting staff dashboard data:', error);
        return {
            stats: { activeCases: 0, pendingSignatures: 0, completedToday: 0, failedChecks: 0 },
            cases: []
        };
    }
}

// ============================================================================
// PORTAL DATA FUNCTIONS
// ============================================================================

/**
 * Get defendant portal data
 */
export async function getDefendantPortalData(personId, caseId) {
    try {
        let caseData = null;

        if (caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, caseId, { suppressAuth: true });
        } else if (personId) {
            const results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('_id', personId)
                .find({ suppressAuth: true });
            if (results.items.length > 0) {
                caseData = results.items[0];
            }
        }

        if (!caseData) {
            return { success: false, message: 'Case not found' };
        }

        // Get pending documents
        const pendingDocs = await wixData.query('PendingDocuments')
            .eq('caseNumber', caseData.caseNumber)
            .eq('status', 'pending')
            .find({ suppressAuth: true });

        return {
            success: true,
            case: {
                caseNumber: caseData.caseNumber,
                defendantName: caseData.defendantName,
                bondAmount: caseData.bondAmount,
                county: caseData.county,
                status: caseData.status,
                charges: caseData.charges
            },
            pendingDocuments: pendingDocs.items,
            requiresIdUpload: !caseData.idUploaded
        };

    } catch (error) {
        console.error('Error getting defendant portal data:', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get indemnitor portal data
 */
export async function getIndemnitorPortalData(personId, caseId) {
    try {
        let caseData = null;

        if (caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, caseId, { suppressAuth: true });
        } else if (personId && personId.startsWith('indemnitor_')) {
            const actualCaseId = personId.replace('indemnitor_', '');
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, actualCaseId, { suppressAuth: true });
        }

        if (!caseData) {
            return { success: false, message: 'Case not found' };
        }

        // Get pending documents for indemnitor
        const pendingDocs = await wixData.query('PendingDocuments')
            .eq('memberEmail', caseData.indemnitorEmail)
            .eq('status', 'pending')
            .find({ suppressAuth: true });

        return {
            success: true,
            case: {
                caseNumber: caseData.caseNumber,
                defendantName: caseData.defendantName,
                bondAmount: caseData.bondAmount,
                county: caseData.county,
                status: caseData.status
            },
            indemnitor: {
                name: caseData.indemnitorName,
                email: caseData.indemnitorEmail,
                phone: caseData.indemnitorPhone
            },
            pendingDocuments: pendingDocs.items,
            requiresIdUpload: !caseData.indemnitorIdUploaded
        };

    } catch (error) {
        console.error('Error getting indemnitor portal data:', error);
        return { success: false, message: error.message };
    }
}

/**
 * BACKEND: Link Defendant to Existing Case (e.g., from Indemnitor Portal)
 * Allows a user (Defendant) to find their case via Case Number + Indemnitor Name
 */
export async function linkDefendantToCase(caseNumber, indemnitorName) {
    try {
        if (!caseNumber && !indemnitorName) {
            return { success: false, message: 'Please enter a Case Number OR Indemnitor Last Name.' };
        }

        const targetCase = caseNumber ? caseNumber.trim() : null;
        const targetName = indemnitorName ? indemnitorName.trim().toLowerCase() : null;

        console.log(`üîç Searching for case. Number: ${targetCase}, Indemnitor: ${targetName}`);

        let matches = [];

        // 1. Search by Case Number (Exact) - Highest Priority
        if (targetCase) {
            const caseResults = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('caseNumber', targetCase)
                .find({ suppressAuth: true });

            if (caseResults.items.length > 0) {
                matches = caseResults.items;
                console.log(`‚úÖ Found by Case Number: ${matches.length}`);
            }
        }

        // 2. Search by Indemnitor Name (Partial) - Fallback or "OR" logic
        // Only search if we haven't found a match yet, OR if the user wants "Either" (and case lookup failed)
        // If the user provided a name but the case lookup failed (or wasn't provided), we search by name.
        if (matches.length === 0 && targetName) {
            console.log(`üîç Searching by Indemnitor Name: ${targetName}`);
            // Use contains for "Last Name" matching "First Middle Last"
            const nameResults = await wixData.query(CONFIG.CASES_COLLECTION)
                .contains('indemnitorName', targetName) // Case-insensitive in Wix usually, but good to check
                .descending('_createdDate') // Get latest first
                .limit(5) // Limit results for safety
                .find({ suppressAuth: true });

            // Refine: Ensure the user typed at least 3 chars to avoid "a" returning everything
            if (nameResults.items.length > 0 && targetName.length >= 2) {
                // Secondary check: ensure the search term is actually part of the name (JavaScript check for robust matching)
                matches = nameResults.items.filter(item =>
                    (item.indemnitorName || '').toLowerCase().includes(targetName)
                );
                console.log(`‚úÖ Found by Indemnitor Name: ${matches.length}`);
            }
        }

        if (matches.length === 0) {
            return { success: false, message: 'No case found matching your details.' };
        }

        // 3. Selection Strategy: First Match (Most Recent by default due to push/query)
        // If we found multiple by name, we take the top one (latest).
        const caseData = matches[0];

        console.log(`üéØ Matched Case: ${caseData.caseNumber}`);

        // Success! Generate a Session Token for the DEFENDANT role on this case
        const sessionToken = await createCustomSession(
            caseData._id, // Use CaseID as PersonID for defendant
            'defendant',
            caseData._id,
            {
                email: caseData.defendantEmail,
                phone: caseData.defendantPhone,
                name: caseData.defendantName
            }
        );

        return {
            success: true,
            sessionToken: sessionToken,
            wixSessionToken: null,
            message: 'Case found! Redirecting to your paperwork...'
        };

    } catch (error) {
        console.error('Error linking defendant:', error);
        return { success: false, message: error.message };
    }
}

// ============================================================================
// DEFENDANT DETAILS (Required by portal-defendant.skg9y.js)
// ============================================================================

/**
 * Get defendant details by session token
 * Required by portal-defendant.skg9y.js
 */
export async function getDefendantDetails(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            return null;
        }

        // Get case data
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        } else {
            // Try to find by personId
            const results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('_id', session.personId)
                .find({ suppressAuth: true });
            if (results.items.length > 0) {
                caseData = results.items[0];
            }
        }

        if (!caseData) {
            return {
                firstName: 'Client',
                email: '',
                caseNumber: 'Pending',
                bondAmount: '$0.00',
                nextCourtDate: 'TBD',
                caseStatus: 'Pending',
                paperworkStatus: 'Not Started',
                signingStatus: 'Incomplete'
            };
        }

        // Format court date
        let nextCourtDate = 'TBD';
        if (caseData.courtDate) {
            const date = new Date(caseData.courtDate);
            nextCourtDate = date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        // Format bond amount
        let bondAmount = '$0.00';
        if (caseData.bondAmount) {
            bondAmount = '$' + Number(caseData.bondAmount).toLocaleString();
        }

        return {
            firstName: caseData.defendantName?.split(' ')[0] || 'Client',
            lastName: caseData.defendantName?.split(' ').slice(1).join(' ') || '',
            email: caseData.defendantEmail || '',
            phone: caseData.defendantPhone || '',
            caseNumber: caseData.caseNumber || 'Pending',
            bondAmount: bondAmount,
            nextCourtDate: nextCourtDate,
            caseStatus: caseData.status || 'Active',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.signingStatus || 'Incomplete',
            county: caseData.county || '',
            charges: caseData.charges || ''
        };

    } catch (error) {
        console.error('Error getting defendant details:', error);
        return null;
    }
}


/**
 * Get user consent status
 * Required by portal-defendant.skg9y.js
 */
export async function getUserConsentStatus(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { hasConsent: false };
        }

        // Check consent in Persons or Cases collection
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        }

        return {
            hasConsent: caseData?.consentGiven || false,
            consentDate: caseData?.consentDate || null,
            locationConsent: caseData?.locationConsentGiven || false,
            smsConsent: caseData?.smsConsentGiven || false
        };

    } catch (error) {
        console.error('Error getting consent status:', error);
        return { hasConsent: false };
    }
}

// ============================================================================
// INDEMNITOR DETAILS (Required by portal-indemnitor.k53on.js)
// ============================================================================

/**
 * Get indemnitor details by session token
 * Required by portal-indemnitor.k53on.js
 */
export async function getIndemnitorDetails(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            return null;
        }

        // Get case data
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        } else if (session.personId && session.personId.startsWith('indemnitor_')) {
            const actualCaseId = session.personId.replace('indemnitor_', '');
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, actualCaseId, { suppressAuth: true });
        }

        if (!caseData) {
            return {
                firstName: 'Cosigner',
                email: '',
                caseNumber: 'Pending',
                bondAmount: '$0.00',
                defendantName: 'Unknown',
                paperworkStatus: 'Not Started',
                signingStatus: 'Incomplete'
            };
        }

        // Format bond amount
        let bondAmount = '$0.00';
        if (caseData.bondAmount) {
            bondAmount = '$' + Number(caseData.bondAmount).toLocaleString();
        }

        // Calculate financial fields
        const totalLiability = caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00';
        const premiumRate = 0.10; // 10% premium rate
        const totalPremium = caseData.bondAmount ? '$' + (Number(caseData.bondAmount) * premiumRate).toLocaleString() : '$0.00';
        const downPayment = caseData.downPayment ? '$' + Number(caseData.downPayment).toLocaleString() : '$0.00';
        const balanceDue = caseData.balanceDue ? '$' + Number(caseData.balanceDue).toLocaleString() :
            (caseData.bondAmount && caseData.downPayment ?
                '$' + ((Number(caseData.bondAmount) * premiumRate) - Number(caseData.downPayment)).toLocaleString() : '$0.00');

        // Count charges if available
        let chargesCount = '0';
        if (caseData.charges) {
            if (Array.isArray(caseData.charges)) {
                chargesCount = String(caseData.charges.length);
            } else if (typeof caseData.charges === 'string') {
                chargesCount = String(caseData.charges.split(',').length);
            }
        }

        return {
            // Basic info
            firstName: caseData.indemnitorName?.split(' ')[0] || 'Cosigner',
            lastName: caseData.indemnitorName?.split(' ').slice(1).join(' ') || '',
            email: caseData.indemnitorEmail || '',
            phone: caseData.indemnitorPhone || '',
            caseNumber: caseData.caseNumber || 'Pending',
            bondAmount: bondAmount,
            defendantName: caseData.defendantName || 'Unknown',
            caseStatus: caseData.status || 'Active',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.indemnitorSigningStatus || 'Incomplete',
            county: caseData.county || '',
            relationship: caseData.indemnitorRelationship || '',

            // Financial fields for dashboard
            totalLiability: totalLiability,
            totalPremium: totalPremium,
            downPayment: downPayment,
            balanceDue: balanceDue,
            chargesCount: chargesCount,

            // Defendant status fields
            defendantStatus: caseData.defendantStatus || 'In Custody',
            lastCheckIn: caseData.lastCheckIn ? new Date(caseData.lastCheckIn).toLocaleDateString() : 'Never',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD'
        };

    } catch (error) {
        console.error('Error getting indemnitor details:', error);
        return null;
    }
}

// ============================================================================
// MULTI-CASE LOOKUP FUNCTIONS
// ============================================================================

/**
 * Get ALL cases where the user appears as an indemnitor
 * Supports many-to-many relationship: one indemnitor can sign for multiple defendants
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, cases: [...], totalCases }
 */
export async function getIndemnitorLinkedCases(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { success: false, cases: [], totalCases: 0, error: 'Invalid session' };
        }

        const email = normalizeEmail(session.email);
        const phone = normalizePhone(session.phone);

        if (!email && !phone) {
            return { success: false, cases: [], totalCases: 0, error: 'No contact info in session' };
        }

        // Build queries to find all cases where this person is an indemnitor
        let allCases = [];

        // Query 1: Check single indemnitorEmail field
        if (email) {
            const emailQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorEmail', email)
                .find({ suppressAuth: true });
            allCases = allCases.concat(emailQuery.items);
        }

        // Query 2: Check single indemnitorPhone field
        if (phone) {
            const phoneQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorPhone', phone)
                .find({ suppressAuth: true });
            // Avoid duplicates
            phoneQuery.items.forEach(item => {
                if (!allCases.find(c => c._id === item._id)) {
                    allCases.push(item);
                }
            });
        }

        // Query 3: Check indemnitorEmails array (if exists)
        if (email) {
            try {
                const arrayQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                    .hasSome('indemnitorEmails', [email])
                    .find({ suppressAuth: true });
                arrayQuery.items.forEach(item => {
                    if (!allCases.find(c => c._id === item._id)) {
                        allCases.push(item);
                    }
                });
            } catch (e) {
                // Field may not exist, ignore
            }
        }

        // Query 4: Check indemnitor2Email, indemnitor3Email, etc. (numbered fields)
        for (let i = 2; i <= 5; i++) {
            if (email) {
                try {
                    const numberedQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                        .eq('indemnitor' + i + 'Email', email)
                        .find({ suppressAuth: true });
                    numberedQuery.items.forEach(item => {
                        if (!allCases.find(c => c._id === item._id)) {
                            allCases.push(item);
                        }
                    });
                } catch (e) {
                    // Field may not exist, ignore
                }
            }
        }

        // Format cases for frontend display
        const formattedCases = allCases.map(caseData => ({
            caseId: caseData._id,
            caseNumber: caseData.caseNumber || 'Pending',
            defendantName: caseData.defendantName || 'Unknown',
            defendantStatus: caseData.defendantStatus || caseData.status || 'Active',
            bondAmount: caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00',
            county: caseData.county || '',
            arrestDate: caseData.arrestDate ? new Date(caseData.arrestDate).toLocaleDateString() : 'N/A',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.indemnitorSigningStatus || 'Incomplete',
            charges: caseData.charges || '',
            createdDate: caseData._createdDate ? new Date(caseData._createdDate).toLocaleDateString() : 'N/A'
        }));

        // Sort by created date (newest first)
        formattedCases.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));

        return {
            success: true,
            cases: formattedCases,
            totalCases: formattedCases.length,
            indemnitorEmail: email,
            indemnitorPhone: phone
        };

    } catch (error) {
        console.error('Error in getIndemnitorLinkedCases:', error);
        return { success: false, cases: [], totalCases: 0, error: error.message };
    }
}

/**
 * Get ALL cases where the user appears as a defendant
 * Supports the scenario where a person can be a defendant in some cases and indemnitor in others
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, cases: [...], totalCases }
 */
export async function getDefendantLinkedCases(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { success: false, cases: [], totalCases: 0, error: 'Invalid session' };
        }

        const email = normalizeEmail(session.email);
        const phone = normalizePhone(session.phone);

        if (!email && !phone) {
            return { success: false, cases: [], totalCases: 0, error: 'No contact info in session' };
        }

        let allCases = [];

        // Query by defendant email
        if (email) {
            const emailQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('defendantEmail', email)
                .find({ suppressAuth: true });
            allCases = allCases.concat(emailQuery.items);
        }

        // Query by defendant phone
        if (phone) {
            const phoneQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('defendantPhone', phone)
                .find({ suppressAuth: true });
            phoneQuery.items.forEach(item => {
                if (!allCases.find(c => c._id === item._id)) {
                    allCases.push(item);
                }
            });
        }

        // Format cases for frontend display
        const formattedCases = allCases.map(caseData => ({
            caseId: caseData._id,
            caseNumber: caseData.caseNumber || 'Pending',
            defendantName: caseData.defendantName || 'Unknown',
            status: caseData.status || 'Active',
            bondAmount: caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00',
            county: caseData.county || '',
            arrestDate: caseData.arrestDate ? new Date(caseData.arrestDate).toLocaleDateString() : 'N/A',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.defendantSigningStatus || 'Incomplete',
            charges: caseData.charges || '',
            indemnitorName: caseData.indemnitorName || 'N/A',
            createdDate: caseData._createdDate ? new Date(caseData._createdDate).toLocaleDateString() : 'N/A'
        }));

        formattedCases.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));

        return {
            success: true,
            cases: formattedCases,
            totalCases: formattedCases.length,
            defendantEmail: email,
            defendantPhone: phone
        };

    } catch (error) {
        console.error('Error in getDefendantLinkedCases:', error);
        return { success: false, cases: [], totalCases: 0, error: error.message };
    }
}

/**
 * Get ALL roles and cases for a user (both as indemnitor AND defendant)
 * This is the master lookup function for users who may have multiple roles
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, indemnitorCases: [...], defendantCases: [...], totalCases }
 */
export async function getAllUserCases(sessionToken) {
    try {
        const [indemnitorResult, defendantResult] = await Promise.all([
            getIndemnitorLinkedCases(sessionToken),
            getDefendantLinkedCases(sessionToken)
        ]);

        return {
            success: true,
            indemnitorCases: indemnitorResult.cases || [],
            defendantCases: defendantResult.cases || [],
            totalIndemnitorCases: indemnitorResult.totalCases || 0,
            totalDefendantCases: defendantResult.totalCases || 0,
            totalCases: (indemnitorResult.totalCases || 0) + (defendantResult.totalCases || 0)
        };

    } catch (error) {
        console.error('Error in getAllUserCases:', error);
        return {
            success: false,
            indemnitorCases: [],
            defendantCases: [],
            totalCases: 0,
            error: error.message
        };
    }
}

/**
 * Get pending paperwork for an indemnitor across all their linked cases
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, pendingDocuments: [...] }
 */
export async function getIndemnitorPendingPaperwork(sessionToken) {
    try {
        const casesResult = await getIndemnitorLinkedCases(sessionToken);
        if (!casesResult.success) {
            return { success: false, pendingDocuments: [], error: casesResult.error };
        }

        // Get pending documents for each case
        const pendingDocuments = [];
        for (const caseInfo of casesResult.cases) {
            if (caseInfo.signingStatus !== 'Complete' && caseInfo.signingStatus !== 'Signed') {
                // Query PendingDocuments collection for this case
                try {
                    const docsQuery = await wixData.query('PendingDocuments')
                        .eq('caseId', caseInfo.caseId)
                        .ne('status', 'signed')
                        .find({ suppressAuth: true });

                    docsQuery.items.forEach(doc => {
                        pendingDocuments.push({
                            documentId: doc._id,
                            caseId: caseInfo.caseId,
                            caseNumber: caseInfo.caseNumber,
                            defendantName: caseInfo.defendantName,
                            documentName: doc.documentName || 'Bail Bond Document',
                            signingLink: doc.signingLink || '',
                            status: doc.status || 'pending',
                            createdDate: doc._createdDate ? new Date(doc._createdDate).toLocaleDateString() : 'N/A'
                        });
                    });
                } catch (e) {
                    console.warn('Could not query documents for case ' + caseInfo.caseId + ':', e);
                }
            }
        }

        return {
            success: true,
            pendingDocuments: pendingDocuments,
            totalPending: pendingDocuments.length
        };

    } catch (error) {
        console.error('Error in getIndemnitorPendingPaperwork:', error);
        return { success: false, pendingDocuments: [], error: error.message };
    }
}
// ============================================================================
// EXPORTS
// ============================================================================

/**
 * Alias for sendMagicLinkSimplified for backward compatibility
 * Used by magic-link-manager.jsw
 */
export async function sendMagicLink(email, token, role, personName = null) {
    // This is a simplified alias that sends an email with an existing token
    try {
        const magicLinkUrl = `${CONFIG.BASE_URL}${CONFIG.PORTAL_LANDING}?token=${encodeURIComponent(token)}`;
        const result = await sendMagicLinkEmail(email, magicLinkUrl, role, personName);
        return result;
    } catch (error) {
        console.error('Error in sendMagicLink:', error);
        return { success: false, error: error.message };
    }
}

export {
    CONFIG as AUTH_CONFIG,
    isStaffAccount,
    getStaffAccountDetails
};
