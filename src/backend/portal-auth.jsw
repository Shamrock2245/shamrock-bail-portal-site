/**
 * Portal Authentication Module
 * backend/portal-auth.jsw
 * 
 * Complete authentication system for Shamrock Bail Bonds Portal
 * Handles magic links, session management, and role-based access
 * 
 * STAFF LOGIN POLICY:
 * - admin@shamrockbailbonds.biz → Admin role (full access)
 * - shamrockbailoffice@gmail.com → Staff role (standard access)
 * - All other users → Default to indemnitor role (or defendant if found in Cases)
 * 
 * @version 2.0.0
 * @updated 2026-01-23
 */

import wixData from 'wix-data';
import { generateToken, hashPassword, verifyPassword } from 'backend/auth-utils';
import { getGasUrl, getGasApiKey } from 'backend/utils';
import { sendSms } from 'backend/twilio-client';
import { fetch } from 'wix-fetch';
import crypto from 'crypto';

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
    // Session settings
    SESSION_DURATION_HOURS: 24,
    MAGIC_LINK_EXPIRY_HOURS: 24,

    // Collections
    SESSIONS_COLLECTION: 'Portal Sessions',
    MAGIC_LINKS_COLLECTION: 'Magiclinks',
    CASES_COLLECTION: 'Cases',

    // Portal URLs
    BASE_URL: 'https://www.shamrockbailbonds.biz',
    PORTAL_LANDING: '/portal-landing',

    // Hardcoded Staff Accounts
    STAFF_ACCOUNTS: {
        'admin@shamrockbailbonds.biz': {
            role: 'admin',
            personId: 'staff_admin_primary',
            name: 'Admin'
        },
        'shamrockbailoffice@gmail.com': {
            role: 'staff',
            personId: 'staff_office_secondary',
            name: 'Staff'
        }
    }
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================



/**
 * Normalize email to lowercase
 */
function normalizeEmail(email) {
    return email ? email.toLowerCase().trim() : '';
}

/**
 * Normalize phone number to E.164 format
 */
function normalizePhone(phone) {
    if (!phone) return '';
    let digits = phone.replace(/\D/g, '');
    if (digits.length === 10) {
        return '+1' + digits;
    } else if (digits.length === 11 && digits.startsWith('1')) {
        return '+' + digits;
    }
    return phone;
}

/**
 * Check if input is email or phone
 */
function isEmail(input) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input);
}

// ============================================================================
// STAFF ACCOUNT HELPERS
// ============================================================================

/**
 * Check if email is a hardcoded staff account
 */
function isStaffAccount(email) {
    const normalized = normalizeEmail(email);
    return CONFIG.STAFF_ACCOUNTS.hasOwnProperty(normalized);
}

/**
 * Get staff account details
 */
function getStaffAccountDetails(email) {
    const normalized = normalizeEmail(email);
    return CONFIG.STAFF_ACCOUNTS[normalized] || null;
}

// ============================================================================
// USER LOOKUP
// ============================================================================

/**
 * Look up user by email or phone in Cases collection
 * Returns role and person info if found
 */
export async function lookupUserByContact(contact) {
    try {
        const normalized = isEmail(contact)
            ? normalizeEmail(contact)
            : normalizePhone(contact);

        // 1. Check if it's a hardcoded staff account
        if (isEmail(contact) && isStaffAccount(contact)) {
            const staffDetails = getStaffAccountDetails(contact);
            return {
                found: true,
                personId: staffDetails.personId,
                role: staffDetails.role,
                email: normalized,
                name: staffDetails.name,
                isStaff: true
            };
        }

        // 2. Search in Cases collection
        let query = wixData.query(CONFIG.CASES_COLLECTION);

        if (isEmail(contact)) {
            // Check defendant email
            query = query.eq('defendantEmail', normalized);
        } else {
            // Check defendant phone
            query = query.eq('defendantPhone', normalized);
        }

        let results = await query.find({ suppressAuth: true });

        if (results.items.length > 0) {
            const caseData = results.items[0];
            return {
                found: true,
                personId: caseData._id,
                role: 'defendant',
                caseId: caseData._id,
                email: caseData.defendantEmail,
                phone: caseData.defendantPhone,
                name: caseData.defendantName
            };
        }

        // 3. Check indemnitor fields
        if (isEmail(contact)) {
            query = wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorEmail', normalized);
        } else {
            query = wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorPhone', normalized);
        }

        results = await query.find({ suppressAuth: true });

        if (results.items.length > 0) {
            const caseData = results.items[0];
            return {
                found: true,
                personId: 'indemnitor_' + caseData._id,
                role: 'indemnitor',
                caseId: caseData._id,
                email: caseData.indemnitorEmail,
                phone: caseData.indemnitorPhone,
                name: caseData.indemnitorName
            };
        }

        // 4. Not found - will be treated as new user
        return {
            found: false,
            contact: normalized
        };

    } catch (error) {
        console.error('Error in lookupUserByContact:', error);
        return { found: false, error: error.message };
    }
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

/**
 * Create a custom session for a user
 * @param {string} personId
 * @param {string} role
 * @param {string} caseId
 * @param {Object} contactInfo - { email, phone, name } (optional)
 */
export async function createCustomSession(personId, role, caseId = null, contactInfo = {}) {
    try {
        const sessionToken = generateToken(48);
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + CONFIG.SESSION_DURATION_HOURS);

        const sessionData = {
            sessionToken: sessionToken,
            personId: personId,
            role: role,
            caseId: caseId,
            email: contactInfo.email || null,
            phone: contactInfo.phone || null,
            name: contactInfo.name || null,
            createdAt: new Date(),
            expiresAt: expiresAt,
            isActive: true
        };

        await wixData.insert(CONFIG.SESSIONS_COLLECTION, sessionData, { suppressAuth: true });

        console.log(`✅ Session created for ${personId} with role ${role}`);
        return sessionToken;

    } catch (error) {
        console.error('Error creating session:', error);
        throw error;
    }
}

/**
 * Validate a custom session token
 */
export async function validateCustomSession(sessionToken) {
    try {
        if (!sessionToken) {
            return null;
        }

        const results = await wixData.query(CONFIG.SESSIONS_COLLECTION)
            .eq('sessionToken', sessionToken)
            .eq('isActive', true)
            .find({ suppressAuth: true });

        if (results.items.length === 0) {
            console.log('⚠️ Session not found or inactive');
            return null;
        }

        const session = results.items[0];

        // Check expiration
        if (new Date(session.expiresAt) < new Date()) {
            console.log('⚠️ Session expired');
            // Mark as inactive
            session.isActive = false;
            await wixData.update(CONFIG.SESSIONS_COLLECTION, session, { suppressAuth: true });
            return null;
        }

        return {
            personId: session.personId,
            role: session.role,
            caseId: session.caseId,
            email: session.email,
            phone: session.phone,
            name: session.name,
            createdAt: session.createdAt,
            expiresAt: session.expiresAt
        };

    } catch (error) {
        console.error('Error validating session:', error);
        return null;
    }
}

/**
 * Invalidate a session (logout)
 */
export async function invalidateSession(sessionToken) {
    try {
        const results = await wixData.query(CONFIG.SESSIONS_COLLECTION)
            .eq('sessionToken', sessionToken)
            .find({ suppressAuth: true });

        if (results.items.length > 0) {
            const session = results.items[0];
            session.isActive = false;
            session.invalidatedAt = new Date();
            await wixData.update(CONFIG.SESSIONS_COLLECTION, session, { suppressAuth: true });
        }

        return { success: true };

    } catch (error) {
        console.error('Error invalidating session:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// MAGIC LINK GENERATION & VALIDATION
// ============================================================================

/**
 * Generate a magic link token
 * @param {string} personId - Person identifier
 * @param {string} role - User role
 * @param {string} caseId - Case identifier (optional)
 * @param {Object} options - { email, phone, name } (optional)
 */
export async function generateMagicLink(personId, role, caseId = null, options = {}) {
    try {
        const token = generateToken(32);
        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + CONFIG.MAGIC_LINK_EXPIRY_HOURS);

        const linkData = {
            token: token,
            personId: personId,
            role: role,
            caseId: caseId,
            email: options.email || null,
            phone: options.phone || null,
            name: options.name || null,
            createdAt: new Date(),
            expiresAt: expiresAt,
            used: false
        };

        await wixData.insert(CONFIG.MAGIC_LINKS_COLLECTION, linkData, { suppressAuth: true });

        console.log(`✅ Magic link generated for ${personId} (${options.email || 'no-email'})`);
        return token;

    } catch (error) {
        console.error('Error generating magic link:', error);
        throw error;
    }
}

/**
 * Validate magic link token and create session
 */
export async function onMagicLinkLoginV2(token) {
    try {
        if (!token) {
            return { ok: false, message: 'No token provided' };
        }

        // Find the magic link (allow used ones for grace period check)
        const results = await wixData.query(CONFIG.MAGIC_LINKS_COLLECTION)
            .eq('token', token)
            .find({ suppressAuth: true });

        if (results.items.length === 0) {
            return { ok: false, message: 'Invalid or expired link' };
        }

        const linkData = results.items[0];
        const now = new Date();

        // Anti-Scanner Logic: If used < 60 seconds ago, allow it (idempotency)
        if (linkData.used) {
            const usedAt = new Date(linkData.usedAt);
            const timeDiff = now - usedAt;
            if (timeDiff < 60000) { // 60 second grace period
                console.log('⚠️ Token reused within grace period (Scanner defense)');
                // Create session anyway
                const sessionToken = await createCustomSession(
                    linkData.personId,
                    linkData.role,
                    linkData.caseId,
                    {
                        email: linkData.email,
                        phone: linkData.phone,
                        name: linkData.name
                    }
                );
                return {
                    ok: true,
                    sessionToken: sessionToken,
                    role: linkData.role,
                    personId: linkData.personId
                };
            }
            return { ok: false, message: 'Link already used' };
        }

        // ... Normal flow ...

        // Check expiration
        if (new Date(linkData.expiresAt) < now) {
            return { ok: false, message: 'Link has expired' };
        }

        // Mark as used
        linkData.used = true;
        linkData.usedAt = now;
        await wixData.update(CONFIG.MAGIC_LINKS_COLLECTION, linkData, { suppressAuth: true });

        // Create session
        const sessionToken = await createCustomSession(
            linkData.personId,
            linkData.role,
            linkData.caseId,
            {
                email: linkData.email,
                phone: linkData.phone,
                name: linkData.name
            }
        );

        return {
            ok: true,
            sessionToken: sessionToken,
            role: linkData.role,
            personId: linkData.personId
        };

    } catch (error) {
        console.error('Error validating magic link:', error);
        return { ok: false, message: error.message };
    }
}

// ============================================================================
// SIMPLIFIED MAGIC LINK FLOW (Main Entry Point)
// ============================================================================

/**
 * Simplified magic link flow - single entry point for portal-landing
 * Handles both email and phone, new and existing users
 */
export async function sendMagicLinkSimplified(emailOrPhone) {
    try {
        const input = emailOrPhone.trim();
        const isEmailInput = isEmail(input);

        // 1. Look up user
        const lookup = await lookupUserByContact(input);

        let personId, role, caseId, email, phone, name;
        let isNewUser = false;

        if (lookup.found) {
            // Existing user
            personId = lookup.personId;
            role = lookup.role;
            caseId = lookup.caseId;
            email = lookup.email;
            phone = lookup.phone;
            name = lookup.name;
        } else {
            // New user - default to indemnitor role
            isNewUser = true;
            personId = 'new_' + generateToken(16);
            role = 'indemnitor';
            email = isEmailInput ? normalizeEmail(input) : null;
            phone = !isEmailInput ? normalizePhone(input) : null;
            name = null;
        }

        // 2. Generate magic link
        const token = await generateMagicLink(personId, role, caseId, {
            email: email,
            phone: phone,
            name: name
        });
        const magicLinkUrl = `${CONFIG.BASE_URL}${CONFIG.PORTAL_LANDING}?token=${encodeURIComponent(token)}`;

        // 3. Send via appropriate channel
        if (isEmailInput && email) {
            // Send via email
            const emailResult = await sendMagicLinkEmail(email, magicLinkUrl, role, name);
            if (!emailResult.success) {
                return { success: false, message: 'Failed to send email: ' + emailResult.error };
            }
        } else if (!isEmailInput && phone) {
            // Send via SMS
            const smsBody = `Shamrock Bail Bonds: Access your secure portal here: ${magicLinkUrl}. This link expires in 24 hours. Reply STOP to opt out.`;
            const smsResult = await sendSms(phone, smsBody);
            if (!smsResult.success) {
                return { success: false, message: 'Failed to send SMS: ' + smsResult.error };
            }
        } else {
            return { success: false, message: 'Unable to determine contact method' };
        }

        return {
            success: true,
            isNewUser: isNewUser,
            role: role,
            message: isEmailInput
                ? 'Check your email for your secure login link'
                : 'Check your phone for your secure login link'
        };

    } catch (error) {
        console.error('Error in sendMagicLinkSimplified:', error);
        return { success: false, message: error.message };
    }
}

/**
 * Send magic link via email
 */
async function sendMagicLinkEmail(email, magicLinkUrl, role, name) {
    try {
        // Use GAS backend to send email
        const gasUrl = await getGasUrl();
        const apiKey = await getGasApiKey();

        const roleLabels = {
            'admin': 'Administrator',
            'staff': 'Staff',
            'defendant': 'Client',
            'indemnitor': 'Cosigner'
        };

        const emailBody = `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <div style="background: #1a5f2a; padding: 20px; text-align: center;">
                    <h1 style="color: white; margin: 0;">Shamrock Bail Bonds</h1>
                </div>
                <div style="padding: 30px; background: #f9f9f9;">
                    <p>Hello${name ? ' ' + name : ''},</p>
                    <p>Click the button below to securely access your ${roleLabels[role] || 'Client'} Portal:</p>
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="${magicLinkUrl}" style="background: #1a5f2a; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold;">
                            Access Your Portal
                        </a>
                    </div>
                    <p style="color: #666; font-size: 14px;">This link will expire in 24 hours.</p>
                    <p style="color: #666; font-size: 14px;">If you didn't request this link, please ignore this email.</p>
                </div>
                <div style="background: #333; color: white; padding: 15px; text-align: center; font-size: 12px;">
                    <p style="margin: 0;">Shamrock Bail Bonds, LLC</p>
                    <p style="margin: 5px 0;">1528 Broadway, Fort Myers, FL 33901</p>
                    <p style="margin: 0;">(239) 332-2245</p>
                </div>
            </div>
        `;

        const response = await fetch(gasUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'sendEmail',
                apiKey: apiKey,
                to: email,
                subject: 'Your Secure Portal Access - Shamrock Bail Bonds',
                htmlBody: emailBody
            })
        });

        if (!response.ok) {
            throw new Error('Email send failed: ' + response.status);
        }

        return { success: true };

    } catch (error) {
        console.error('Error sending magic link email:', error);
        return { success: false, error: error.message };
    }
}

// ============================================================================
// STAFF DASHBOARD DATA
// ============================================================================

/**
 * Get staff dashboard data (stats and cases)
 */
export async function getStaffDashboardData() {
    try {
        // Get all cases
        const casesResult = await wixData.query(CONFIG.CASES_COLLECTION)
            .descending('_createdDate')
            .limit(100)
            .find({ suppressAuth: true });

        const cases = casesResult.items;

        // Calculate stats
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const stats = {
            activeCases: cases.filter(c => c.status === 'active' || c.status === 'pending').length,
            pendingSignatures: cases.filter(c => c.paperworkStatus === 'pending').length,
            completedToday: cases.filter(c => {
                const created = new Date(c._createdDate);
                return created >= today && c.status === 'completed';
            }).length,
            failedChecks: cases.filter(c => c.status === 'failed').length
        };

        // Format cases for display
        const formattedCases = cases.map(c => ({
            _id: c._id,
            caseNumber: c.caseNumber || 'N/A',
            defendantName: c.defendantName || 'Unknown',
            bondAmount: c.bondAmount ? '$' + Number(c.bondAmount).toLocaleString() : 'N/A',
            status: c.status || 'pending',
            paperworkStatus: c.paperworkStatus || 'not_started',
            county: c.county || 'N/A',
            createdAt: c._createdDate
        }));

        return {
            stats: stats,
            cases: formattedCases
        };

    } catch (error) {
        console.error('Error getting staff dashboard data:', error);
        return {
            stats: { activeCases: 0, pendingSignatures: 0, completedToday: 0, failedChecks: 0 },
            cases: []
        };
    }
}

// ============================================================================
// PORTAL DATA FUNCTIONS
// ============================================================================

/**
 * Get defendant portal data
 */
export async function getDefendantPortalData(personId, caseId) {
    try {
        let caseData = null;

        if (caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, caseId, { suppressAuth: true });
        } else if (personId) {
            const results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('_id', personId)
                .find({ suppressAuth: true });
            if (results.items.length > 0) {
                caseData = results.items[0];
            }
        }

        if (!caseData) {
            return { success: false, message: 'Case not found' };
        }

        // Get pending documents
        const pendingDocs = await wixData.query('PendingDocuments')
            .eq('caseNumber', caseData.caseNumber)
            .eq('status', 'pending')
            .find({ suppressAuth: true });

        return {
            success: true,
            case: {
                caseNumber: caseData.caseNumber,
                defendantName: caseData.defendantName,
                bondAmount: caseData.bondAmount,
                county: caseData.county,
                status: caseData.status,
                charges: caseData.charges
            },
            pendingDocuments: pendingDocs.items,
            requiresIdUpload: !caseData.idUploaded
        };

    } catch (error) {
        console.error('Error getting defendant portal data:', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get indemnitor portal data
 */
export async function getIndemnitorPortalData(personId, caseId) {
    try {
        let caseData = null;

        if (caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, caseId, { suppressAuth: true });
        } else if (personId && personId.startsWith('indemnitor_')) {
            const actualCaseId = personId.replace('indemnitor_', '');
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, actualCaseId, { suppressAuth: true });
        }

        if (!caseData) {
            return { success: false, message: 'Case not found' };
        }

        // Get pending documents for indemnitor
        const pendingDocs = await wixData.query('PendingDocuments')
            .eq('memberEmail', caseData.indemnitorEmail)
            .eq('status', 'pending')
            .find({ suppressAuth: true });

        return {
            success: true,
            case: {
                caseNumber: caseData.caseNumber,
                defendantName: caseData.defendantName,
                bondAmount: caseData.bondAmount,
                county: caseData.county,
                status: caseData.status
            },
            indemnitor: {
                name: caseData.indemnitorName,
                email: caseData.indemnitorEmail,
                phone: caseData.indemnitorPhone
            },
            pendingDocuments: pendingDocs.items,
            requiresIdUpload: !caseData.indemnitorIdUploaded
        };

    } catch (error) {
        console.error('Error getting indemnitor portal data:', error);
        return { success: false, message: error.message };
    }
}

// ============================================================================
// DEFENDANT DETAILS (Required by portal-defendant.skg9y.js)
// ============================================================================

/**
 * Get defendant details by session token
 * Required by portal-defendant.skg9y.js
 */
export async function getDefendantDetails(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            return null;
        }

        // Get case data
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        } else {
            // Try to find by personId
            const results = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('_id', session.personId)
                .find({ suppressAuth: true });
            if (results.items.length > 0) {
                caseData = results.items[0];
            }
        }

        if (!caseData) {
            return {
                firstName: 'Client',
                email: '',
                caseNumber: 'Pending',
                bondAmount: '$0.00',
                nextCourtDate: 'TBD',
                caseStatus: 'Pending',
                paperworkStatus: 'Not Started',
                signingStatus: 'Incomplete'
            };
        }

        // Format court date
        let nextCourtDate = 'TBD';
        if (caseData.courtDate) {
            const date = new Date(caseData.courtDate);
            nextCourtDate = date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        // Format bond amount
        let bondAmount = '$0.00';
        if (caseData.bondAmount) {
            bondAmount = '$' + Number(caseData.bondAmount).toLocaleString();
        }

        return {
            firstName: caseData.defendantName?.split(' ')[0] || 'Client',
            lastName: caseData.defendantName?.split(' ').slice(1).join(' ') || '',
            email: caseData.defendantEmail || '',
            phone: caseData.defendantPhone || '',
            caseNumber: caseData.caseNumber || 'Pending',
            bondAmount: bondAmount,
            nextCourtDate: nextCourtDate,
            caseStatus: caseData.status || 'Active',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.signingStatus || 'Incomplete',
            county: caseData.county || '',
            charges: caseData.charges || ''
        };

    } catch (error) {
        console.error('Error getting defendant details:', error);
        return null;
    }
}


/**
 * Get user consent status
 * Required by portal-defendant.skg9y.js
 */
export async function getUserConsentStatus(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { hasConsent: false };
        }

        // Check consent in Persons or Cases collection
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        }

        return {
            hasConsent: caseData?.consentGiven || false,
            consentDate: caseData?.consentDate || null,
            locationConsent: caseData?.locationConsentGiven || false,
            smsConsent: caseData?.smsConsentGiven || false
        };

    } catch (error) {
        console.error('Error getting consent status:', error);
        return { hasConsent: false };
    }
}

// ============================================================================
// INDEMNITOR DETAILS (Required by portal-indemnitor.k53on.js)
// ============================================================================

/**
 * Get indemnitor details by session token
 * Required by portal-indemnitor.k53on.js
 */
export async function getIndemnitorDetails(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            return null;
        }

        // Get case data
        let caseData = null;
        if (session.caseId) {
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, session.caseId, { suppressAuth: true });
        } else if (session.personId && session.personId.startsWith('indemnitor_')) {
            const actualCaseId = session.personId.replace('indemnitor_', '');
            caseData = await wixData.get(CONFIG.CASES_COLLECTION, actualCaseId, { suppressAuth: true });
        }

        if (!caseData) {
            return {
                firstName: 'Cosigner',
                email: '',
                caseNumber: 'Pending',
                bondAmount: '$0.00',
                defendantName: 'Unknown',
                paperworkStatus: 'Not Started',
                signingStatus: 'Incomplete'
            };
        }

        // Format bond amount
        let bondAmount = '$0.00';
        if (caseData.bondAmount) {
            bondAmount = '$' + Number(caseData.bondAmount).toLocaleString();
        }

        // Calculate financial fields
        const totalLiability = caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00';
        const premiumRate = 0.10; // 10% premium rate
        const totalPremium = caseData.bondAmount ? '$' + (Number(caseData.bondAmount) * premiumRate).toLocaleString() : '$0.00';
        const downPayment = caseData.downPayment ? '$' + Number(caseData.downPayment).toLocaleString() : '$0.00';
        const balanceDue = caseData.balanceDue ? '$' + Number(caseData.balanceDue).toLocaleString() :
            (caseData.bondAmount && caseData.downPayment ?
                '$' + ((Number(caseData.bondAmount) * premiumRate) - Number(caseData.downPayment)).toLocaleString() : '$0.00');

        // Count charges if available
        let chargesCount = '0';
        if (caseData.charges) {
            if (Array.isArray(caseData.charges)) {
                chargesCount = String(caseData.charges.length);
            } else if (typeof caseData.charges === 'string') {
                chargesCount = String(caseData.charges.split(',').length);
            }
        }

        return {
            // Basic info
            firstName: caseData.indemnitorName?.split(' ')[0] || 'Cosigner',
            lastName: caseData.indemnitorName?.split(' ').slice(1).join(' ') || '',
            email: caseData.indemnitorEmail || '',
            phone: caseData.indemnitorPhone || '',
            caseNumber: caseData.caseNumber || 'Pending',
            bondAmount: bondAmount,
            defendantName: caseData.defendantName || 'Unknown',
            caseStatus: caseData.status || 'Active',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.indemnitorSigningStatus || 'Incomplete',
            county: caseData.county || '',
            relationship: caseData.indemnitorRelationship || '',

            // Financial fields for dashboard
            totalLiability: totalLiability,
            totalPremium: totalPremium,
            downPayment: downPayment,
            balanceDue: balanceDue,
            chargesCount: chargesCount,

            // Defendant status fields
            defendantStatus: caseData.defendantStatus || 'In Custody',
            lastCheckIn: caseData.lastCheckIn ? new Date(caseData.lastCheckIn).toLocaleDateString() : 'Never',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD'
        };

    } catch (error) {
        console.error('Error getting indemnitor details:', error);
        return null;
    }
}

// ============================================================================
// MULTI-CASE LOOKUP FUNCTIONS
// ============================================================================

/**
 * Get ALL cases where the user appears as an indemnitor
 * Supports many-to-many relationship: one indemnitor can sign for multiple defendants
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, cases: [...], totalCases }
 */
export async function getIndemnitorLinkedCases(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { success: false, cases: [], totalCases: 0, error: 'Invalid session' };
        }

        const email = normalizeEmail(session.email);
        const phone = normalizePhone(session.phone);

        if (!email && !phone) {
            return { success: false, cases: [], totalCases: 0, error: 'No contact info in session' };
        }

        // Build queries to find all cases where this person is an indemnitor
        let allCases = [];

        // Query 1: Check single indemnitorEmail field
        if (email) {
            const emailQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorEmail', email)
                .find({ suppressAuth: true });
            allCases = allCases.concat(emailQuery.items);
        }

        // Query 2: Check single indemnitorPhone field
        if (phone) {
            const phoneQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('indemnitorPhone', phone)
                .find({ suppressAuth: true });
            // Avoid duplicates
            phoneQuery.items.forEach(item => {
                if (!allCases.find(c => c._id === item._id)) {
                    allCases.push(item);
                }
            });
        }

        // Query 3: Check indemnitorEmails array (if exists)
        if (email) {
            try {
                const arrayQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                    .hasSome('indemnitorEmails', [email])
                    .find({ suppressAuth: true });
                arrayQuery.items.forEach(item => {
                    if (!allCases.find(c => c._id === item._id)) {
                        allCases.push(item);
                    }
                });
            } catch (e) {
                // Field may not exist, ignore
            }
        }

        // Query 4: Check indemnitor2Email, indemnitor3Email, etc. (numbered fields)
        for (let i = 2; i <= 5; i++) {
            if (email) {
                try {
                    const numberedQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                        .eq('indemnitor' + i + 'Email', email)
                        .find({ suppressAuth: true });
                    numberedQuery.items.forEach(item => {
                        if (!allCases.find(c => c._id === item._id)) {
                            allCases.push(item);
                        }
                    });
                } catch (e) {
                    // Field may not exist, ignore
                }
            }
        }

        // Format cases for frontend display
        const formattedCases = allCases.map(caseData => ({
            caseId: caseData._id,
            caseNumber: caseData.caseNumber || 'Pending',
            defendantName: caseData.defendantName || 'Unknown',
            defendantStatus: caseData.defendantStatus || caseData.status || 'Active',
            bondAmount: caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00',
            county: caseData.county || '',
            arrestDate: caseData.arrestDate ? new Date(caseData.arrestDate).toLocaleDateString() : 'N/A',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.indemnitorSigningStatus || 'Incomplete',
            charges: caseData.charges || '',
            createdDate: caseData._createdDate ? new Date(caseData._createdDate).toLocaleDateString() : 'N/A'
        }));

        // Sort by created date (newest first)
        formattedCases.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));

        return {
            success: true,
            cases: formattedCases,
            totalCases: formattedCases.length,
            indemnitorEmail: email,
            indemnitorPhone: phone
        };

    } catch (error) {
        console.error('Error in getIndemnitorLinkedCases:', error);
        return { success: false, cases: [], totalCases: 0, error: error.message };
    }
}

/**
 * Get ALL cases where the user appears as a defendant
 * Supports the scenario where a person can be a defendant in some cases and indemnitor in others
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, cases: [...], totalCases }
 */
export async function getDefendantLinkedCases(sessionToken) {
    try {
        const session = await validateCustomSession(sessionToken);
        if (!session) {
            return { success: false, cases: [], totalCases: 0, error: 'Invalid session' };
        }

        const email = normalizeEmail(session.email);
        const phone = normalizePhone(session.phone);

        if (!email && !phone) {
            return { success: false, cases: [], totalCases: 0, error: 'No contact info in session' };
        }

        let allCases = [];

        // Query by defendant email
        if (email) {
            const emailQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('defendantEmail', email)
                .find({ suppressAuth: true });
            allCases = allCases.concat(emailQuery.items);
        }

        // Query by defendant phone
        if (phone) {
            const phoneQuery = await wixData.query(CONFIG.CASES_COLLECTION)
                .eq('defendantPhone', phone)
                .find({ suppressAuth: true });
            phoneQuery.items.forEach(item => {
                if (!allCases.find(c => c._id === item._id)) {
                    allCases.push(item);
                }
            });
        }

        // Format cases for frontend display
        const formattedCases = allCases.map(caseData => ({
            caseId: caseData._id,
            caseNumber: caseData.caseNumber || 'Pending',
            defendantName: caseData.defendantName || 'Unknown',
            status: caseData.status || 'Active',
            bondAmount: caseData.bondAmount ? '$' + Number(caseData.bondAmount).toLocaleString() : '$0.00',
            county: caseData.county || '',
            arrestDate: caseData.arrestDate ? new Date(caseData.arrestDate).toLocaleDateString() : 'N/A',
            nextCourtDate: caseData.nextCourtDate ? new Date(caseData.nextCourtDate).toLocaleDateString() : 'TBD',
            paperworkStatus: caseData.paperworkStatus || 'Pending',
            signingStatus: caseData.defendantSigningStatus || 'Incomplete',
            charges: caseData.charges || '',
            indemnitorName: caseData.indemnitorName || 'N/A',
            createdDate: caseData._createdDate ? new Date(caseData._createdDate).toLocaleDateString() : 'N/A'
        }));

        formattedCases.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));

        return {
            success: true,
            cases: formattedCases,
            totalCases: formattedCases.length,
            defendantEmail: email,
            defendantPhone: phone
        };

    } catch (error) {
        console.error('Error in getDefendantLinkedCases:', error);
        return { success: false, cases: [], totalCases: 0, error: error.message };
    }
}

/**
 * Get ALL roles and cases for a user (both as indemnitor AND defendant)
 * This is the master lookup function for users who may have multiple roles
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, indemnitorCases: [...], defendantCases: [...], totalCases }
 */
export async function getAllUserCases(sessionToken) {
    try {
        const [indemnitorResult, defendantResult] = await Promise.all([
            getIndemnitorLinkedCases(sessionToken),
            getDefendantLinkedCases(sessionToken)
        ]);

        return {
            success: true,
            indemnitorCases: indemnitorResult.cases || [],
            defendantCases: defendantResult.cases || [],
            totalIndemnitorCases: indemnitorResult.totalCases || 0,
            totalDefendantCases: defendantResult.totalCases || 0,
            totalCases: (indemnitorResult.totalCases || 0) + (defendantResult.totalCases || 0)
        };

    } catch (error) {
        console.error('Error in getAllUserCases:', error);
        return {
            success: false,
            indemnitorCases: [],
            defendantCases: [],
            totalCases: 0,
            error: error.message
        };
    }
}

/**
 * Get pending paperwork for an indemnitor across all their linked cases
 * @param {string} sessionToken - The session token
 * @returns {Object} - { success, pendingDocuments: [...] }
 */
export async function getIndemnitorPendingPaperwork(sessionToken) {
    try {
        const casesResult = await getIndemnitorLinkedCases(sessionToken);
        if (!casesResult.success) {
            return { success: false, pendingDocuments: [], error: casesResult.error };
        }

        // Get pending documents for each case
        const pendingDocuments = [];
        for (const caseInfo of casesResult.cases) {
            if (caseInfo.signingStatus !== 'Complete' && caseInfo.signingStatus !== 'Signed') {
                // Query PendingDocuments collection for this case
                try {
                    const docsQuery = await wixData.query('PendingDocuments')
                        .eq('caseId', caseInfo.caseId)
                        .ne('status', 'signed')
                        .find({ suppressAuth: true });

                    docsQuery.items.forEach(doc => {
                        pendingDocuments.push({
                            documentId: doc._id,
                            caseId: caseInfo.caseId,
                            caseNumber: caseInfo.caseNumber,
                            defendantName: caseInfo.defendantName,
                            documentName: doc.documentName || 'Bail Bond Document',
                            signingLink: doc.signingLink || '',
                            status: doc.status || 'pending',
                            createdDate: doc._createdDate ? new Date(doc._createdDate).toLocaleDateString() : 'N/A'
                        });
                    });
                } catch (e) {
                    console.warn('Could not query documents for case ' + caseInfo.caseId + ':', e);
                }
            }
        }

        return {
            success: true,
            pendingDocuments: pendingDocuments,
            totalPending: pendingDocuments.length
        };

    } catch (error) {
        console.error('Error in getIndemnitorPendingPaperwork:', error);
        return { success: false, pendingDocuments: [], error: error.message };
    }
}
// ============================================================================
// EXPORTS
// ============================================================================

/**
 * Alias for sendMagicLinkSimplified for backward compatibility
 * Used by magic-link-manager.jsw
 */
export async function sendMagicLink(email, token, role, personName = null) {
    // This is a simplified alias that sends an email with an existing token
    try {
        const magicLinkUrl = `${CONFIG.BASE_URL}${CONFIG.PORTAL_LANDING}?token=${encodeURIComponent(token)}`;
        const result = await sendMagicLinkEmail(email, magicLinkUrl, role, personName);
        return result;
    } catch (error) {
        console.error('Error in sendMagicLink:', error);
        return { success: false, error: error.message };
    }
}

export {
    CONFIG as AUTH_CONFIG,
    isStaffAccount,
    getStaffAccountDetails
};
