import wixData from 'wix-data';
// REMOVED: import { currentMember } from 'wix-members-backend';
import { fetch } from 'wix-fetch';
import { getGasWebAppUrl } from 'backend/secretsManager';
import { getSecret } from 'wix-secrets-backend';
import { fetchWithRetry } from 'backend/utils';
import { validateCustomSession } from 'backend/portal-auth';
import { analyzeLocationRisk } from 'backend/fraud-detection'; // Static import

/**
 * Save user location to the database and sync to Google Sheets
 * Refactored for Custom Session Auth (No Wix Members)
 * 
 * @param {number} latitude - GPS latitude
 * @param {number} longitude - GPS longitude
 * @param {string} [notes] - Optional comments
 * @param {string} [imageUrl] - Optional URL of selfie
 * @param {string} sessionToken - REQUIRED: Custom session token
 * @returns {Promise<{success: boolean, message: string}>}
 */
export async function saveUserLocation(latitude, longitude, notes = "", imageUrl = "", sessionToken, extraData = {}) {
    try {
        console.log("LocationBackend: Saving location...");

        if (!sessionToken) {
            console.error("LocationBackend: Missing session token");
            // Check if we can proceed with just IP/device logging? No, we need a user context usually.
            // But for "robustness", maybe we log anonymous hits? sticking to auth for now.
            return { success: false, message: 'Unauthorized: Missing token' };
        }

        // Validate Token
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            console.error("LocationBackend: Invalid session");
            return { success: false, message: 'Unauthorized: Invalid session' };
        }

        const personId = session.personId;
        const email = session.email || `user_${personId}@shamrock.local`;

        // Extract extra data
        const {
            ipAddress = '',
            deviceModel = '',
            os = '',
            browser = '',
            phoneNumber = '',
            userAgent = ''
        } = extraData;

        // 1. Get Last Location (for risk/velocity)
        const lastLocation = await getLastLocation(personId);

        // 2. Risk Analysis
        const { riskLevel, riskFactors } = analyzeLocationRisk(latitude, longitude, lastLocation);

        // 3. Reverse Geocoding
        let address = 'Unknown';
        let intersection = 'Unknown';
        let city = '';
        let region = '';
        let country = 'US';
        let postalCode = '';

        try {
            const apiKey = await getSecret('GOOGLE_MAPS_API_KEY');
            if (apiKey) {
                const geoResponse = await fetchWithRetry(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=${apiKey}`);
                if (geoResponse.ok) {
                    const geoData = await geoResponse.json();
                    if (geoData.status === 'OK' && geoData.results.length > 0) {
                        address = geoData.results[0].formatted_address;

                        // Extract address components for a robust Wix Address Object
                        geoData.results[0].address_components.forEach(component => {
                            if (component.types.includes('locality')) {
                                city = component.long_name;
                            }
                            if (component.types.includes('administrative_area_level_1')) {
                                region = component.short_name; // e.g., 'FL'
                            }
                            if (component.types.includes('country')) {
                                country = component.short_name; // e.g., 'US'
                            }
                            if (component.types.includes('postal_code')) {
                                postalCode = component.long_name;
                            }
                        });

                        const intersectionResult = geoData.results.find(r => r.types.includes('intersection'));
                        if (intersectionResult) intersection = intersectionResult.formatted_address;
                    }
                }
            }
        } catch (geoError) {
            console.warn('LocationBackend: Geocoding failed', geoError);
        }

        // Build robust Wix Address Object
        const addressObj = {
            formatted: address,
            location: {
                latitude: Number(latitude),
                longitude: Number(longitude)
            },
            city: city,
            subdivision: region,
            country: country,
            postalCode: postalCode
        };

        const locationData = {
            memberId: String(personId || ''),
            memberEmail: String(email || ''),
            phoneNumber: String(phoneNumber || session.phone || ''),
            latitude: String(latitude),
            longitude: String(longitude),
            address: addressObj, // Send fully formatted Address object
            intersection: String(intersection || ''),
            timestamp: new Date(),
            notes: String(notes || ''),
            imageUrl: String(imageUrl || ''),
            ipAddress: String(ipAddress || ''),
            deviceModel: String(deviceModel || ''),
            os: String(os || ''),
            browser: String(browser || ''),
            userAgent: String(userAgent || 'Portal Custom Auth'),
            riskLevel: String(riskLevel || ''),
            riskFactors: Array.isArray(riskFactors) ? riskFactors.join(', ') : String(riskFactors || ''),
            isHighRisk: Boolean(riskLevel === 'HIGH')
        };

        // 4. Save to UserLocations
        await wixData.insert('UserLocations', locationData);

        // 5. Sync to GAS
        try {
            const gasUrl = await getGasWebAppUrl();
            if (gasUrl) {
                await fetchWithRetry(gasUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'logDefendantLocation',
                        data: {
                            ...locationData,
                            timestamp: locationData.timestamp.toISOString()
                        }
                    })
                });
            }
        } catch (gasError) {
            console.error('LocationBackend: GAS sync failed', gasError);
        }

        return {
            success: true,
            message: 'Check-in successful',
            address,
            riskAlert: riskLevel === 'HIGH' ? 'High Risk Detected' : null
        };

    } catch (error) {
        console.error('LocationBackend: Critical Error', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get the current location for the logged-in member
 * Returns the most recent location record or triggers a new location request
 * @returns {Promise<{success: boolean, location?: Object, message?: string}>}
 */
export async function getCurrentLocation() {
    return { success: false, message: 'Not implemented for custom auth' };
}

/**
 * Get the last known location for a member
 * @param {string} memberId - The member ID
 * @returns {Promise<Object|null>}
 */
export async function getLastLocation(memberId) {
    try {
        const results = await wixData.query('UserLocations')
            .eq('memberId', memberId)
            .descending('timestamp')
            .limit(1)
            .find();

        return results.items.length > 0 ? results.items[0] : null;

    } catch (error) {
        console.error('Error getting last location:', error);
        return null;
    }
}
