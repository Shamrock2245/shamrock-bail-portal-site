import wixData from 'wix-data';
// REMOVED: import { currentMember } from 'wix-members-backend';
import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';
import { fetchWithRetry } from 'backend/utils';
import { validateCustomSession } from 'backend/portal-auth';

/**
 * Save user location to the database and sync to Google Sheets
 * Refactored for Custom Session Auth (No Wix Members)
 * 
 * @param {number} latitude - GPS latitude
 * @param {number} longitude - GPS longitude
 * @param {string} [notes] - Optional comments
 * @param {string} [imageUrl] - Optional URL of selfie
 * @param {string} sessionToken - REQUIRED: Custom session token
 * @returns {Promise<{success: boolean, message: string}>}
 */
export async function saveUserLocation(latitude, longitude, notes = "", imageUrl = "", sessionToken) {
    try {
        console.log("LocationBackend: Saving location...");

        if (!sessionToken) {
            console.error("LocationBackend: Missing session token");
            return { success: false, message: 'Unauthorized: Missing token' };
        }

        // Validate Token
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            console.error("LocationBackend: Invalid session");
            return { success: false, message: 'Unauthorized: Invalid session' };
        }

        const personId = session.personId;
        const email = session.email || `user_${personId}@shamrock.local`; // Fallback if email not in session yet

        // 1. Get Last Location (for risk/velocity)
        const lastLocation = await getLastLocation(personId);

        // 2. Risk Analysis (Dynamically imported)
        // Note: Check if fraud-detection needs updating too, but assuming it just does math
        const { analyzeLocationRisk } = await import('backend/fraud-detection');
        const { riskLevel, riskFactors } = analyzeLocationRisk(latitude, longitude, lastLocation);

        // 3. Reverse Geocoding
        let address = 'Unknown';
        let intersection = 'Unknown';

        try {
            const apiKey = await getSecret('GOOGLE_MAPS_API_KEY');
            if (apiKey) {
                const geoResponse = await fetchWithRetry(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=${apiKey}`);
                if (geoResponse.ok) {
                    const geoData = await geoResponse.json();
                    if (geoData.status === 'OK' && geoData.results.length > 0) {
                        address = geoData.results[0].formatted_address;
                        const intersectionResult = geoData.results.find(r => r.types.includes('intersection'));
                        if (intersectionResult) intersection = intersectionResult.formatted_address;
                    }
                }
            }
        } catch (geoError) {
            console.warn('LocationBackend: Geocoding failed', geoError);
        }

        const locationData = {
            memberId: personId, // Using personId as memberId for compatibility
            memberEmail: email,
            latitude: latitude,
            longitude: longitude,
            address: address,
            intersection: intersection,
            timestamp: new Date(),
            notes: notes || "",
            imageUrl: imageUrl || "",
            userAgent: 'Portal Custom Auth',
            riskLevel: riskLevel,
            riskFactors: riskFactors,
            isHighRisk: riskLevel === 'HIGH'
        };

        // 4. Save to UserLocations
        await wixData.insert('UserLocations', locationData);

        // 5. Sync to GAS
        try {
            const gasUrl = await getSecret('GAS_WEB_APP_URL');
            if (gasUrl) {
                await fetchWithRetry(gasUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'logDefendantLocation',
                        data: {
                            ...locationData,
                            timestamp: locationData.timestamp.toISOString()
                        }
                    })
                });
            }
        } catch (gasError) {
            console.error('LocationBackend: GAS sync failed', gasError);
        }

        return {
            success: true,
            message: 'Check-in successful',
            address,
            riskAlert: riskLevel === 'HIGH' ? 'High Risk Detected' : null
        };

    } catch (error) {
        console.error('LocationBackend: Critical Error', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get the current location for the logged-in member
 * Returns the most recent location record or triggers a new location request
 * @returns {Promise<{success: boolean, location?: Object, message?: string}>}
 */
export async function getCurrentLocation() {
    try {
        const member = await currentMember.getMember();

        if (!member) {
            return { success: false, message: 'User not logged in' };
        }

        // Get the most recent location
        const results = await wixData.query('UserLocations')
            .eq('memberId', member._id)
            .descending('timestamp')
            .limit(1)
            .find();

        if (results.items.length > 0) {
            const location = results.items[0];
            const locationAge = Date.now() - new Date(location.timestamp).getTime();
            const isRecent = locationAge < 30 * 60 * 1000; // Less than 30 minutes old

            return {
                success: true,
                location: {
                    latitude: location.latitude,
                    longitude: location.longitude,
                    address: location.address,
                    intersection: location.intersection,
                    timestamp: location.timestamp,
                    isRecent: isRecent
                },
                message: isRecent ? 'Recent location found' : 'Location may be outdated'
            };
        }

        return {
            success: false,
            message: 'No location data available. Please enable location services.'
        };

    } catch (error) {
        console.error('Error getting current location:', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get the last known location for a member
 * @param {string} memberId - The member ID
 * @returns {Promise<Object|null>}
 */
export async function getLastLocation(memberId) {
    try {
        const results = await wixData.query('UserLocations')
            .eq('memberId', memberId)
            .descending('timestamp')
            .limit(1)
            .find();

        return results.items.length > 0 ? results.items[0] : null;

    } catch (error) {
        console.error('Error getting last location:', error);
        return null;
    }
}
