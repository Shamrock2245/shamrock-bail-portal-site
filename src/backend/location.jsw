import wixData from 'wix-data';
// REMOVED: import { currentMember } from 'wix-members-backend';
import { fetch } from 'wix-fetch';
import { getGasWebAppUrl } from 'backend/secretsManager';
import { getSecret } from 'wix-secrets-backend';
import { fetchWithRetry } from 'backend/utils';
import { validateCustomSession } from 'backend/portal-auth';
import { analyzeLocationRisk } from 'backend/fraud-detection'; // Static import

/**
 * Save user location to the database and sync to Google Sheets
 * Refactored for Custom Session Auth (No Wix Members)
 * 
 * @param {number} latitude - GPS latitude
 * @param {number} longitude - GPS longitude
 * @param {string} [notes] - Optional comments
 * @param {string} [imageUrl] - Optional URL of selfie
 * @param {string} sessionToken - REQUIRED: Custom session token
 * @returns {Promise<{success: boolean, message: string}>}
 */
export async function saveUserLocation(latitude, longitude, notes = "", imageUrl = "", sessionToken, extraData = {}) {
    try {
        console.log("LocationBackend: Saving location...");

        if (!sessionToken) {
            console.error("LocationBackend: Missing session token");
            // Check if we can proceed with just IP/device logging? No, we need a user context usually.
            // But for "robustness", maybe we log anonymous hits? sticking to auth for now.
            return { success: false, message: 'Unauthorized: Missing token' };
        }

        // Validate Token
        const session = await validateCustomSession(sessionToken);
        if (!session || !session.personId) {
            console.error("LocationBackend: Invalid session");
            return { success: false, message: 'Unauthorized: Invalid session' };
        }

        const personId = session.personId;
        const email = session.email || `user_${personId}@shamrock.local`;

        // Extract extra data
        const {
            ipAddress = '',
            deviceModel = '',
            os = '',
            browser = '',
            phoneNumber = '',
            userAgent = ''
        } = extraData;

        // 1. Get Last Location (for risk/velocity)
        const lastLocation = await getLastLocation(personId);

        // 2. Risk Analysis
        const { riskLevel, riskFactors } = analyzeLocationRisk(latitude, longitude, lastLocation);

        // 3. Reverse Geocoding
        let address = 'Unknown';
        let intersection = 'Unknown';

        try {
            const apiKey = await getSecret('GOOGLE_MAPS_API_KEY');
            if (apiKey) {
                const geoResponse = await fetchWithRetry(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=${apiKey}`);
                if (geoResponse.ok) {
                    const geoData = await geoResponse.json();
                    if (geoData.status === 'OK' && geoData.results.length > 0) {
                        address = geoData.results[0].formatted_address;
                        const intersectionResult = geoData.results.find(r => r.types.includes('intersection'));
                        if (intersectionResult) intersection = intersectionResult.formatted_address;
                    }
                }
            }
        } catch (geoError) {
            console.warn('LocationBackend: Geocoding failed', geoError);
        }

        const locationData = {
            memberId: personId,
            memberEmail: email,
            phoneNumber: phoneNumber || session.phone || '', // Try session phone if available
            latitude,
            longitude,
            address,
            intersection,
            timestamp: new Date(),
            notes: notes || "",
            imageUrl: imageUrl || "",
            ipAddress,
            deviceModel,
            os,
            browser,
            userAgent: userAgent || 'Portal Custom Auth',
            riskLevel,
            riskFactors,
            isHighRisk: riskLevel === 'HIGH'
        };

        // 4. Save to UserLocations
        await wixData.insert('UserLocations', locationData);

        // 5. Sync to GAS
        try {
            const gasUrl = await getGasWebAppUrl();
            if (gasUrl) {
                await fetchWithRetry(gasUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'logDefendantLocation',
                        data: {
                            ...locationData,
                            timestamp: locationData.timestamp.toISOString()
                        }
                    })
                });
            }
        } catch (gasError) {
            console.error('LocationBackend: GAS sync failed', gasError);
        }

        return {
            success: true,
            message: 'Check-in successful',
            address,
            riskAlert: riskLevel === 'HIGH' ? 'High Risk Detected' : null
        };

    } catch (error) {
        console.error('LocationBackend: Critical Error', error);
        return { success: false, message: error.message };
    }
}

/**
 * Get the current location for the logged-in member
 * Returns the most recent location record or triggers a new location request
 * @returns {Promise<{success: boolean, location?: Object, message?: string}>}
 */
export async function getCurrentLocation() {
    return { success: false, message: 'Not implemented for custom auth' };
}

/**
 * Get the last known location for a member
 * @param {string} memberId - The member ID
 * @returns {Promise<Object|null>}
 */
export async function getLastLocation(memberId) {
    try {
        const results = await wixData.query('UserLocations')
            .eq('memberId', memberId)
            .descending('timestamp')
            .limit(1)
            .find();

        return results.items.length > 0 ? results.items[0] : null;

    } catch (error) {
        console.error('Error getting last location:', error);
        return null;
    }
}
