/**
 * Portal API Client Module
 * 
 * Handles all communication with the external REST API
 * Provides wrapper functions for API endpoints with error handling
 * 
 * @module portal-api-client
 */

import { fetch } from 'wix-fetch';
import { API_BASE_URL, API_TIMEOUT, ERROR_MESSAGES } from 'public/portal-config';

// ============================================================================
// Core API Functions
// ============================================================================

/**
 * Make an API call to the external backend
 * 
 * @param {string} endpoint - API endpoint (e.g., '/persons')
 * @param {string} method - HTTP method (GET, POST, PATCH, DELETE)
 * @param {Object} data - Request body data
 * @param {string} token - Authorization token (JWT or magic link token)
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} API response data
 * @throws {Error} If API call fails
 */
export async function apiCall(endpoint, method = 'GET', data = null, token = null, options = {}) {
  const url = `${API_BASE_URL}${endpoint}`;

  const headers = {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  };

  // Add authorization header if token provided
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  // Add idempotency key for critical operations
  if (options.idempotencyKey) {
    headers['Idempotency-Key'] = options.idempotencyKey;
  }

  const requestOptions = {
    method,
    headers
  };

  // Add body for POST, PATCH, PUT requests
  if (data && ['POST', 'PATCH', 'PUT'].includes(method)) {
    requestOptions.body = JSON.stringify(data);
  }

  try {
    const response = await fetch(url, requestOptions);

    // Handle different response status codes
    if (response.status === 401) {
      throw new Error(ERROR_MESSAGES.AUTH_ERROR);
    }

    if (response.status === 403) {
      throw new Error(ERROR_MESSAGES.PERMISSION_ERROR);
    }

    if (response.status === 404) {
      throw new Error(ERROR_MESSAGES.NOT_FOUND);
    }

    if (response.status >= 500) {
      throw new Error(ERROR_MESSAGES.SERVER_ERROR);
    }

    // Parse JSON response
    const responseData = await response.json();

    // Check if response indicates an error
    if (!response.ok) {
      throw new Error(responseData.message || ERROR_MESSAGES.SERVER_ERROR);
    }

    return responseData;

  } catch (error) {
    console.error('API call failed:', {
      endpoint,
      method,
      error: error.message
    });

    // Re-throw with more context
    if (error.message.includes('fetch')) {
      throw new Error(ERROR_MESSAGES.NETWORK_ERROR);
    }

    throw error;
  }
}

// ============================================================================
// Persons API
// ============================================================================

/**
 * Create a new person record
 * 
 * @param {Object} personData - Person data matching Person schema
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Created person with person_id
 */
export async function createPerson(personData, token) {
  return await apiCall('/persons', 'POST', personData, token);
}

/**
 * Update an existing person record
 * 
 * @param {string} personId - Person ID
 * @param {Object} updates - Partial person data to update
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Updated person record
 */
export async function updatePerson(personId, updates, token) {
  return await apiCall(`/persons/${personId}`, 'PATCH', updates, token);
}

/**
 * Get person by ID
 * 
 * @param {string} personId - Person ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Person record
 */
export async function getPerson(personId, token) {
  return await apiCall(`/persons/${personId}`, 'GET', null, token);
}

// ============================================================================
// Cases API
// ============================================================================

/**
 * Create a new case
 * 
 * @param {Object} caseData - Case data matching Case schema
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Created case with case_id
 */
export async function createCase(caseData, token) {
  return await apiCall('/cases', 'POST', caseData, token);
}

/**
 * Update an existing case
 * 
 * @param {string} caseId - Case ID
 * @param {Object} updates - Partial case data to update
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Updated case record
 */
export async function updateCase(caseId, updates, token) {
  return await apiCall(`/cases/${caseId}`, 'PATCH', updates, token);
}

/**
 * Get case by ID
 * 
 * @param {string} caseId - Case ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Case record
 */
export async function getCase(caseId, token) {
  return await apiCall(`/cases/${caseId}`, 'GET', null, token);
}

/**
 * List cases with filters
 * 
 * @param {Object} filters - Query filters (status, county, etc.)
 * @param {string} token - Authorization token
 * @returns {Promise<Array>} List of cases
 */
export async function listCases(filters, token) {
  const queryParams = new URLSearchParams(filters).toString();
  const endpoint = `/cases${queryParams ? '?' + queryParams : ''}`;
  return await apiCall(endpoint, 'GET', null, token);
}

// ============================================================================
// Documents API
// ============================================================================

/**
 * Create a new document instance
 * 
 * @param {Object} documentData - Document data with case_id, document_key, payload
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Created document with document_id
 */
export async function createDocument(documentData, token) {
  return await apiCall('/documents', 'POST', documentData, token);
}

/**
 * Update document payload
 * 
 * @param {string} documentId - Document ID
 * @param {Object} payload - Updated document payload
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Updated document record
 */
export async function updateDocument(documentId, payload, token) {
  return await apiCall(`/documents/${documentId}`, 'PATCH', { payload }, token);
}

/**
 * Get document by ID
 * 
 * @param {string} documentId - Document ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Document record
 */
export async function getDocument(documentId, token) {
  return await apiCall(`/documents/${documentId}`, 'GET', null, token);
}

/**
 * Render document as PDF
 * 
 * @param {string} documentId - Document ID
 * @param {boolean} withAuditTrail - Include audit trail in PDF
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} PDF URL or binary data
 */
export async function renderDocumentPDF(documentId, withAuditTrail = true, token) {
  return await apiCall(
    `/documents/${documentId}:render`,
    'POST',
    { format: 'pdf', with_audit_trail: withAuditTrail },
    token
  );
}

// ============================================================================
// Signatures API
// ============================================================================

/**
 * Create a signature request
 * 
 * @param {Object} signatureData - Signature data with document_id, signed_by_person_id, etc.
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Created signature with signature_id
 */
export async function createSignature(signatureData, token) {
  return await apiCall('/signatures/requests', 'POST', signatureData, token);
}

/**
 * Get signature by ID
 * 
 * @param {string} signatureId - Signature ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Signature record
 */
export async function getSignature(signatureId, token) {
  return await apiCall(`/signatures/${signatureId}`, 'GET', null, token);
}

/**
 * List signatures for a document
 * 
 * @param {string} documentId - Document ID
 * @param {string} token - Authorization token
 * @returns {Promise<Array>} List of signatures
 */
export async function listDocumentSignatures(documentId, token) {
  return await apiCall(`/documents/${documentId}/signatures`, 'GET', null, token);
}

// ============================================================================
// Payments API
// ============================================================================

/**
 * Authorize a payment
 * 
 * @param {Object} paymentData - Payment authorization data
 * @param {string} token - Authorization token
 * @param {string} idempotencyKey - Idempotency key for payment safety
 * @returns {Promise<Object>} Payment authorization with payment_id
 */
export async function authorizePayment(paymentData, token, idempotencyKey) {
  return await apiCall(
    '/payments/authorize',
    'POST',
    paymentData,
    token,
    { idempotencyKey }
  );
}

/**
 * Capture an authorized payment
 * 
 * @param {string} paymentId - Payment ID
 * @param {number} amount - Amount to capture (optional, defaults to full authorization)
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Captured payment record
 */
export async function capturePayment(paymentId, amount = null, token) {
  const data = amount ? { amount } : {};
  return await apiCall(`/payments/${paymentId}:capture`, 'POST', data, token);
}

/**
 * Get payment by ID
 * 
 * @param {string} paymentId - Payment ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Payment record
 */
export async function getPayment(paymentId, token) {
  return await apiCall(`/payments/${paymentId}`, 'GET', null, token);
}

/**
 * Get payment receipt PDF
 * 
 * @param {string} paymentId - Payment ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Receipt PDF URL or binary data
 */
export async function getPaymentReceipt(paymentId, token) {
  return await apiCall(`/payments/${paymentId}/receipt`, 'GET', null, token);
}

/**
 * List payments for a case
 * 
 * @param {string} caseId - Case ID
 * @param {string} token - Authorization token
 * @returns {Promise<Array>} List of payments
 */
export async function listCasePayments(caseId, token) {
  return await apiCall(`/cases/${caseId}/payments`, 'GET', null, token);
}

// ============================================================================
// Check-Ins API
// ============================================================================

/**
 * Create a check-in
 * 
 * @param {Object} checkinData - Check-in data with case_id, person_id, gps, selfie_uri
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Created check-in with checkin_id and certification
 */
export async function createCheckin(checkinData, token) {
  return await apiCall('/checkins', 'POST', checkinData, token);
}

/**
 * Get check-in by ID
 * 
 * @param {string} checkinId - Check-in ID
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Check-in record
 */
export async function getCheckin(checkinId, token) {
  return await apiCall(`/checkins/${checkinId}`, 'GET', null, token);
}

/**
 * List check-ins for a case
 * 
 * @param {string} caseId - Case ID
 * @param {number} limit - Maximum number of results
 * @param {string} token - Authorization token
 * @returns {Promise<Array>} List of check-ins
 */
export async function listCaseCheckins(caseId, limit = 50, token) {
  return await apiCall(`/cases/${caseId}/checkins?limit=${limit}`, 'GET', null, token);
}

// ============================================================================
// File Upload Helper
// ============================================================================

/**
 * Upload a file to the API (for selfies, documents, etc.)
 * 
 * @param {File} file - File object to upload
 * @param {string} fileType - Type of file (selfie, document, signature)
 * @param {string} token - Authorization token
 * @returns {Promise<Object>} Upload response with file URI
 */
export async function uploadFile(file, fileType, token) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('type', fileType);

  const url = `${API_BASE_URL}/upload`;

  const headers = {
    'Authorization': `Bearer ${token}`
  };

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: formData
    });

    if (!response.ok) {
      throw new Error('File upload failed');
    }

    return await response.json();

  } catch (error) {
    console.error('File upload failed:', error);
    throw new Error(ERROR_MESSAGES.SERVER_ERROR);
  }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Generate idempotency key for payment operations
 * 
 * @returns {string} Unique idempotency key
 */
export function generateIdempotencyKey() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Check API health
 * 
 * @returns {Promise<boolean>} True if API is healthy
 */
export async function checkAPIHealth() {
  try {
    const response = await fetch(`${API_BASE_URL}/health`);
    return response.ok;
  } catch (error) {
    console.error('API health check failed:', error);
    return false;
  }
}

// ============================================================================
// Export all functions
// ============================================================================

export default {
  // Core
  apiCall,

  // Persons
  createPerson,
  updatePerson,
  getPerson,

  // Cases
  createCase,
  updateCase,
  getCase,
  listCases,

  // Documents
  createDocument,
  updateDocument,
  getDocument,
  renderDocumentPDF,

  // Signatures
  createSignature,
  getSignature,
  listDocumentSignatures,

  // Payments
  authorizePayment,
  capturePayment,
  getPayment,
  getPaymentReceipt,
  listCasePayments,

  // Check-ins
  createCheckin,
  getCheckin,
  listCaseCheckins,

  // Utilities
  uploadFile,
  generateIdempotencyKey,
  checkAPIHealth
};
