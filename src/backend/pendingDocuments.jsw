/**
 * Shamrock Bail Bonds - PendingDocuments Backend Module
 *
 * This module manages the PendingDocuments CMS collection, which stores
 * SignNow signing links generated by GAS and makes them available to the
 * Wix client portal for embedded signing.
 *
 * FLOW:
 *   GAS generates packet → creates SignNow invite → stores link here
 *   → Client opens Wix portal → reads link from here → opens embedded signing
 *   → SignNow webhook fires → this module updates status → loop closes
 *
 * CMS Collection: PendingDocuments
 * Fields (must exist in Wix CMS):
 *   - title           (Text)      — Auto-generated doc ID (e.g., "DOC-2026-001")
 *   - caseId          (Text)      — Reference to the case
 *   - documentKey     (Text)      — e.g., "financial_indemnity_v1"
 *   - documentName    (Text)      — Human-readable name
 *   - signerEmail     (Text)      — Email of the person who must sign
 *   - signerRole      (Text)      — "defendant" | "indemnitor" | "staff"
 *   - signNowDocId    (Text)      — SignNow document ID
 *   - signingUrl      (Text)      — Embedded signing URL (from SignNow)
 *   - status          (Text)      — "pending" | "viewed" | "signed" | "expired" | "error"
 *   - sentAt          (Date/Time) — When the invite was sent
 *   - signedAt        (Date/Time) — When signing was completed
 *   - expiresAt       (Date/Time) — When the signing link expires
 *   - signedPdfUrl    (Text)      — URL to the completed signed PDF
 *   - idUploadUrl     (Text)      — URL of uploaded government ID (post-sign)
 *   - idUploadedAt    (Date/Time) — When ID was uploaded
 *   - webhookPayload  (Text)      — Raw JSON from SignNow webhook (for audit)
 *   - memberId        (Text)      — Wix member ID (if known)
 *
 * File: backend/pendingDocuments.jsw
 */

import wixData from 'wix-data';

const COLLECTION = 'PendingDocuments';

// ─────────────────────────────────────────────
// READ OPERATIONS
// ─────────────────────────────────────────────

/**
 * Get all pending documents for a given signer email.
 * Used by defendant/indemnitor dashboard to show what needs to be signed.
 *
 * @param {string} signerEmail - The signer's email address
 * @returns {Promise<Array>} Array of pending document records
 */
export async function getPendingDocumentsByEmail(signerEmail) {
    if (!signerEmail) return [];

    try {
        const results = await wixData.query(COLLECTION)
            .eq('signerEmail', signerEmail.toLowerCase().trim())
            .ne('status', 'signed')
            .ne('status', 'expired')
            .descending('sentAt')
            .find({ suppressAuth: true });

        return results.items;
    } catch (error) {
        console.error('[PendingDocuments] Error fetching by email:', error);
        return [];
    }
}

/**
 * Get all documents for a specific case (all signers, all statuses).
 * Used by the staff dashboard for case overview.
 *
 * @param {string} caseId - The case ID
 * @returns {Promise<Array>} All document records for the case
 */
export async function getDocumentsByCase(caseId) {
    try {
        const results = await wixData.query(COLLECTION)
            .eq('caseId', caseId)
            .descending('sentAt')
            .find({ suppressAuth: true });

        return results.items;
    } catch (error) {
        console.error('[PendingDocuments] Error fetching by case:', error);
        return [];
    }
}

/**
 * Get a single document record by its Wix CMS _id.
 *
 * @param {string} docId - The Wix CMS _id
 * @returns {Promise<object|null>}
 */
export async function getDocumentById(docId) {
    try {
        const item = await wixData.get(COLLECTION, docId, { suppressAuth: true });
        return item || null;
    } catch (error) {
        console.error('[PendingDocuments] Error fetching by ID:', error);
        return null;
    }
}

/**
 * Get a document record by its SignNow document ID.
 * Used by the webhook handler to locate the record to update.
 *
 * @param {string} signNowDocId - The SignNow document ID
 * @returns {Promise<object|null>}
 */
export async function getDocumentBySignNowId(signNowDocId) {
    try {
        const results = await wixData.query(COLLECTION)
            .eq('signNowDocId', signNowDocId)
            .find({ suppressAuth: true });

        return results.items.length > 0 ? results.items[0] : null;
    } catch (error) {
        console.error('[PendingDocuments] Error fetching by SignNow ID:', error);
        return null;
    }
}

/**
 * Get case completion summary — how many docs are signed vs. pending.
 * Used by staff dashboard status chips.
 *
 * @param {string} caseId - The case ID
 * @returns {Promise<object>} { total, signed, pending, expired }
 */
export async function getCaseDocumentSummary(caseId) {
    try {
        const docs = await getDocumentsByCase(caseId);

        const summary = {
            total: docs.length,
            signed: 0,
            pending: 0,
            viewed: 0,
            expired: 0,
            error: 0
        };

        for (const doc of docs) {
            const s = doc.status || 'pending';
            if (summary[s] !== undefined) summary[s]++;
            else summary.pending++;
        }

        summary.isComplete = summary.signed === summary.total && summary.total > 0;
        return summary;
    } catch (error) {
        console.error('[PendingDocuments] Error building case summary:', error);
        return { total: 0, signed: 0, pending: 0, isComplete: false };
    }
}

// ─────────────────────────────────────────────
// WRITE OPERATIONS
// ─────────────────────────────────────────────

/**
 * Create a new PendingDocument record.
 * Called by GAS (via Wix HTTP function) after generating a SignNow invite.
 *
 * @param {object} data - Document data from GAS
 * @returns {Promise<object>} Result with success flag and record ID
 */
export async function createPendingDocument(data) {
    try {
        const required = ['caseId', 'signerEmail', 'signerRole', 'signNowDocId', 'signingUrl', 'documentKey'];
        for (const field of required) {
            if (!data[field]) {
                return { success: false, error: `Missing required field: ${field}` };
            }
        }

        const record = {
            title: `DOC-${Date.now()}`,
            caseId: data.caseId,
            documentKey: data.documentKey,
            documentName: data.documentName || formatDocumentName(data.documentKey),
            signerEmail: data.signerEmail.toLowerCase().trim(),
            signerRole: data.signerRole,
            signNowDocId: data.signNowDocId,
            signingUrl: data.signingUrl,
            status: 'pending',
            sentAt: new Date(),
            expiresAt: data.expiresAt ? new Date(data.expiresAt) : getDefaultExpiry(),
            signedAt: null,
            signedPdfUrl: null,
            idUploadUrl: null,
            idUploadedAt: null,
            webhookPayload: null,
            memberId: data.memberId || null
        };

        const inserted = await wixData.insert(COLLECTION, record, { suppressAuth: true });

        return {
            success: true,
            recordId: inserted._id,
            title: inserted.title
        };
    } catch (error) {
        console.error('[PendingDocuments] Error creating document:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Mark a document as viewed (signer opened the signing URL).
 *
 * @param {string} signNowDocId - The SignNow document ID
 * @returns {Promise<object>} Result
 */
export async function markDocumentViewed(signNowDocId) {
    return _updateDocumentStatus(signNowDocId, 'viewed', {});
}

/**
 * Mark a document as signed (called by SignNow webhook).
 * Also stores the signed PDF URL and raw webhook payload for audit.
 *
 * @param {string} signNowDocId  - The SignNow document ID
 * @param {string} signedPdfUrl  - URL to the completed signed PDF
 * @param {string} webhookPayload - Raw JSON string from SignNow webhook
 * @returns {Promise<object>} Result
 */
export async function markDocumentSigned(signNowDocId, signedPdfUrl, webhookPayload) {
    return _updateDocumentStatus(signNowDocId, 'signed', {
        signedAt: new Date(),
        signedPdfUrl: signedPdfUrl || null,
        webhookPayload: webhookPayload || null
    });
}

/**
 * Mark a document as expired.
 *
 * @param {string} signNowDocId - The SignNow document ID
 * @returns {Promise<object>} Result
 */
export async function markDocumentExpired(signNowDocId) {
    return _updateDocumentStatus(signNowDocId, 'expired', {});
}

/**
 * Record a government ID upload against a document record.
 * Called after the signer completes signing and uploads their ID.
 *
 * @param {string} signNowDocId - The SignNow document ID
 * @param {string} idUploadUrl  - Wix Media URL of the uploaded ID
 * @returns {Promise<object>} Result
 */
export async function recordIdUpload(signNowDocId, idUploadUrl) {
    return _updateDocumentStatus(signNowDocId, null, {
        idUploadUrl: idUploadUrl,
        idUploadedAt: new Date()
    });
}

/**
 * Record a government ID upload by Wix CMS record _id.
 * Used when the signer is identified by their record ID rather than SignNow doc ID.
 *
 * @param {string} recordId    - The Wix CMS _id of the PendingDocuments record
 * @param {string} idUploadUrl - Wix Media URL of the uploaded ID
 * @returns {Promise<object>} Result
 */
export async function recordIdUploadById(recordId, idUploadUrl) {
    try {
        const existing = await wixData.get(COLLECTION, recordId, { suppressAuth: true });
        if (!existing) {
            return { success: false, error: 'Document record not found' };
        }

        await wixData.update(COLLECTION, {
            ...existing,
            idUploadUrl: idUploadUrl,
            idUploadedAt: new Date()
        }, { suppressAuth: true });

        return { success: true };
    } catch (error) {
        console.error('[PendingDocuments] Error recording ID upload by ID:', error);
        return { success: false, error: error.message };
    }
}

// ─────────────────────────────────────────────
// CLEANUP
// ─────────────────────────────────────────────

/**
 * Mark all expired documents as "expired" (maintenance function).
 * Can be called from a scheduled job.
 *
 * @returns {Promise<number>} Number of records updated
 */
export async function cleanupExpiredDocuments() {
    try {
        const now = new Date();
        const results = await wixData.query(COLLECTION)
            .eq('status', 'pending')
            .lt('expiresAt', now)
            .find({ suppressAuth: true });

        let count = 0;
        for (const doc of results.items) {
            await wixData.update(COLLECTION, {
                ...doc,
                status: 'expired'
            }, { suppressAuth: true });
            count++;
        }

        console.log(`[PendingDocuments] Expired ${count} documents`);
        return count;
    } catch (error) {
        console.error('[PendingDocuments] Error cleaning up expired documents:', error);
        return 0;
    }
}

// ─────────────────────────────────────────────
// PRIVATE HELPERS
// ─────────────────────────────────────────────

/**
 * Internal helper: update a document's status and optional fields.
 *
 * @param {string} signNowDocId - The SignNow document ID
 * @param {string|null} newStatus - New status value (null = no status change)
 * @param {object} extraFields - Additional fields to update
 * @returns {Promise<object>} Result
 */
async function _updateDocumentStatus(signNowDocId, newStatus, extraFields) {
    try {
        const existing = await getDocumentBySignNowId(signNowDocId);
        if (!existing) {
            return { success: false, error: `No document found for SignNow ID: ${signNowDocId}` };
        }

        const updates = { ...existing, ...extraFields };
        if (newStatus !== null) {
            updates.status = newStatus;
        }

        await wixData.update(COLLECTION, updates, { suppressAuth: true });
        return { success: true };
    } catch (error) {
        console.error('[PendingDocuments] Error updating document status:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Format a document key into a human-readable name.
 * @param {string} key
 * @returns {string}
 */
function formatDocumentName(key) {
    const names = {
        financial_indemnity_v1: 'Financial Indemnity Agreement',
        appearance_application_v1: 'Appearance Bond Application',
        collateral_promissory_v1: 'Collateral Promissory Note',
        bond_info_sheet_v1: 'Bond Information Sheet',
        waiver_authorization_v1: 'Waiver & Authorization',
        ssa_3288_v1: 'SSA Form 3288 (Benefits Release)',
        cc_authorization_v1: 'Credit Card Authorization'
    };
    return names[key] || key;
}

/**
 * Get default expiry date (30 days from now).
 * @returns {Date}
 */
function getDefaultExpiry() {
    const d = new Date();
    d.setDate(d.getDate() + 30);
    return d;
}
